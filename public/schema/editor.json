{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "editor",
  "title": "Editor",
  "description": "Rich text editor with all extensions: image, table, code block, and slash menu.",
  "dependencies": [
    "@tiptap/core",
    "@tiptap/react",
    "@tiptap/starter-kit",
    "@tiptap/extension-text-align",
    "@tiptap/extension-typography",
    "@tiptap/extension-underline",
    "@tiptap/extension-highlight",
    "@tiptap/extension-color",
    "@tiptap/extension-text-style",
    "@tiptap/extension-link",
    "@tiptap/extension-task-list",
    "@tiptap/extension-task-item",
    "@tiptap/extension-placeholder",
    "@tiptap/extension-table",
    "@tiptap/extension-table-row",
    "@tiptap/extension-table-header",
    "@tiptap/extension-table-cell",
    "@tiptap/extension-code-block-lowlight",
    "@tiptap/suggestion",
    "lowlight",
    "lucide-react",
    "react-colorful",
    "tippy.js"
  ],
  "registryDependencies": [
    "button",
    "dropdown-menu",
    "scroll-area",
    "input",
    "popover",
    "tabs"
  ],
  "files": [
    {
      "path": "src/registry/editor/editor.tsx",
      "content": "\"use client\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { Input } from \"@/components/ui/input\"\nimport { ScrollArea } from \"@/components/ui/scroll-area\"\nimport { cn } from \"@/lib/utils\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport * as React from \"react\"\n\nimport {\n  BubbleMenu,\n  Editor,\n  Extensions,\n  FloatingMenu,\n  EditorContent as TiptapEditorContent,\n  useEditorState,\n  useEditor as useTiptapEditor,\n  type UseEditorOptions,\n} from \"@tiptap/react\"\nimport { Check, ChevronDown, ChevronRight, Link2Off } from \"lucide-react\"\nimport { EditorBubbleMenuLink } from \"./editor-link\"\nimport { EDITOR_PLACEHOLDER_CLASSES } from \"./editor-placeholder\"\nimport type { EditorActionKey } from \"./editor.d\"\n\ntype NestedArray<T> = T | NestedArray<T>[]\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface EditorActionConfig<TEditor = unknown> {\n  key: string\n  icon?: React.ElementType\n  label: string\n  description?: string\n  execute: (editor: TEditor, options?: Record<string, unknown>) => void\n  canExecute?: (editor: TEditor) => boolean\n  isActive?: (editor: TEditor) => boolean\n}\n\n// =============================================================================\n// EditorActionRegistry\n// =============================================================================\n\nexport class EditorActionRegistry<TEditor = unknown> {\n  private actions = new Map<string, EditorActionConfig<TEditor>>()\n\n  register(config: EditorActionConfig<TEditor>): this {\n    this.actions.set(config.key, config)\n    return this\n  }\n\n  registerMany(configs: EditorActionConfig<TEditor>[]): this {\n    for (const config of configs) {\n      this.register(config)\n    }\n    return this\n  }\n\n  unregister(key: string): this {\n    this.actions.delete(key)\n    return this\n  }\n\n  extend(registry: EditorActionRegistry<TEditor>): this {\n    for (const config of registry.values()) {\n      this.register(config)\n    }\n    return this\n  }\n\n  get(key: string): EditorActionConfig<TEditor> | undefined {\n    return this.actions.get(key)\n  }\n\n  has(key: string): boolean {\n    return this.actions.has(key)\n  }\n\n  keys(): string[] {\n    return Array.from(this.actions.keys())\n  }\n\n  values(): EditorActionConfig<TEditor>[] {\n    return Array.from(this.actions.values())\n  }\n\n  size(): number {\n    return this.actions.size\n  }\n\n  execute(\n    editor: TEditor | null,\n    key: string,\n    options?: Record<string, unknown>\n  ): void {\n    if (!editor) return\n    const action = this.get(key)\n    action?.execute(editor, options)\n  }\n\n  canExecute(editor: TEditor | null, key: string): boolean {\n    if (!editor) return false\n    const action = this.get(key)\n    return action?.canExecute?.(editor) ?? true\n  }\n\n  isActive(editor: TEditor | null, key: string): boolean {\n    if (!editor) return false\n    const action = this.get(key)\n    return action?.isActive?.(editor) ?? false\n  }\n\n  getActiveKeys(editor: TEditor | null): string[] {\n    if (!editor) return []\n    return this.keys().filter((key) => this.isActive(editor, key))\n  }\n}\n\n// =============================================================================\n// Factory\n// =============================================================================\n\nexport function createEditorRegistry<\n  TEditor = unknown,\n>(): EditorActionRegistry<TEditor> {\n  return new EditorActionRegistry<TEditor>()\n}\n\n/**\n * Default empty registry. Commands are now registered via the `commands`\n * property in `createEditorExtension()`. This empty registry serves as the\n * base that extension commands are merged into.\n *\n * @example\n * ```tsx\n * // Extensions now define their own commands inline:\n * const MyExtension = createEditorExtension({\n *   extension: SomeTiptapExtension,\n *   commands: [\n *     { key: \"myAction\", label: \"My Action\", execute: (editor) => {...} }\n *   ],\n * })\n * ```\n */\nexport const defaultEditorRegistry = createEditorRegistry<Editor>()\n\nexport type EditorExtensions = NestedArray<Extensions[number]>\n\nexport interface BubbleMenuComponentProps {\n  className?: string\n}\n\nexport interface EditorExtensionWithBubbleMenu<TConfig = unknown> {\n  __editorExtension: true\n  extension: EditorExtensions | EditorExtensions[]\n  bubbleMenu?: React.ComponentType<BubbleMenuComponentProps>\n  bubbleMenuProps?: BubbleMenuComponentProps\n  commands?: EditorActionConfig<Editor>[]\n  configure: (\n    options: Partial<TConfig>\n  ) => EditorExtensionWithBubbleMenu<TConfig>\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type EditorExtensionInput =\n  | EditorExtensions\n  | EditorExtensions[]\n  | EditorExtensionWithBubbleMenu<any>\n\nfunction isEditorExtensionWithBubbleMenu(\n  ext: EditorExtensionInput\n): ext is EditorExtensionWithBubbleMenu {\n  return (\n    typeof ext === \"object\" &&\n    ext !== null &&\n    \"__editorExtension\" in ext &&\n    ext.__editorExtension === true\n  )\n}\n\nexport interface CreateEditorExtensionOptions<TConfig = unknown> {\n  extension: EditorExtensions | EditorExtensions[]\n  bubbleMenu?: React.ComponentType<BubbleMenuComponentProps>\n  bubbleMenuProps?: BubbleMenuComponentProps\n  defaultConfig?: TConfig\n  commands?: EditorActionConfig<Editor>[]\n  onConfigure?: (\n    options: Partial<TConfig>,\n    current: CreateEditorExtensionOptions<TConfig>\n  ) => CreateEditorExtensionOptions<TConfig>\n}\n\nexport function createEditorExtension<TConfig = unknown>(\n  options: CreateEditorExtensionOptions<TConfig>\n): EditorExtensionWithBubbleMenu<TConfig> {\n  const result: EditorExtensionWithBubbleMenu<TConfig> = {\n    __editorExtension: true,\n    extension: options.extension,\n    bubbleMenu: options.bubbleMenu,\n    bubbleMenuProps: options.bubbleMenuProps,\n    commands: options.commands,\n    configure(config: Partial<TConfig>) {\n      if (options.onConfigure) {\n        const newOptions = options.onConfigure(config, options)\n        return createEditorExtension(newOptions)\n      }\n\n      const extensions = Array.isArray(options.extension)\n        ? options.extension\n        : [options.extension]\n\n      const configuredExtensions = extensions.map((ext) => {\n        if (\n          ext &&\n          typeof ext === \"object\" &&\n          \"configure\" in ext &&\n          typeof ext.configure === \"function\"\n        ) {\n          return ext.configure(config as Record<string, unknown>)\n        }\n        return ext\n      })\n\n      return createEditorExtension({\n        ...options,\n        extension:\n          configuredExtensions.length === 1\n            ? configuredExtensions[0]\n            : configuredExtensions,\n        bubbleMenuProps: {\n          ...options.bubbleMenuProps,\n          ...((config as Record<string, unknown>)?.bubbleMenuProps as\n            | BubbleMenuComponentProps\n            | undefined),\n        },\n      })\n    },\n  }\n\n  return result\n}\n\nfunction extractExtensionsAndBubbleMenus(inputs: EditorExtensionInput[]): {\n  extensions: EditorExtensions[]\n  bubbleMenus: Array<{\n    component: React.ComponentType<BubbleMenuComponentProps>\n    props?: BubbleMenuComponentProps\n  }>\n  commands: EditorActionConfig<Editor>[]\n} {\n  const extensions: EditorExtensions[] = []\n  const bubbleMenus: Array<{\n    component: React.ComponentType<BubbleMenuComponentProps>\n    props?: BubbleMenuComponentProps\n  }> = []\n  const commands: EditorActionConfig<Editor>[] = []\n\n  for (const input of inputs) {\n    if (isEditorExtensionWithBubbleMenu(input)) {\n      if (Array.isArray(input.extension)) {\n        extensions.push(...input.extension)\n      } else {\n        extensions.push(input.extension)\n      }\n\n      if (input.bubbleMenu) {\n        bubbleMenus.push({\n          component: input.bubbleMenu,\n          props: input.bubbleMenuProps,\n        })\n      }\n\n      if (input.commands) {\n        commands.push(...input.commands)\n      }\n    } else if (Array.isArray(input)) {\n      extensions.push(...input)\n    } else {\n      extensions.push(input)\n    }\n  }\n\n  return { extensions, bubbleMenus, commands }\n}\n\n// =============================================================================\n// Context\n// =============================================================================\n\nexport interface EditorContextValue {\n  editor: Editor | null\n  registry: EditorActionRegistry<Editor>\n}\n\nexport const EditorContext = React.createContext<EditorContextValue | null>(\n  null\n)\n\nexport function useEditor(): EditorContextValue {\n  const ctx = React.useContext(EditorContext)\n  if (!ctx) {\n    throw new Error(\"useEditor must be used within EditorProvider\")\n  }\n  return ctx\n}\n\n// =============================================================================\n// EditorProvider\n// =============================================================================\n\nexport interface EditorProviderProps\n  extends React.PropsWithChildren, Omit<UseEditorOptions, \"extensions\"> {\n  content?: string\n  extensions?: EditorExtensionInput[]\n  registry?: EditorActionRegistry<Editor>\n  className?: string\n}\n\nconst EditorProvider = React.forwardRef<HTMLDivElement, EditorProviderProps>(\n  (\n    {\n      content,\n      extensions = [],\n      registry = defaultEditorRegistry,\n      children,\n      className,\n      ...editorOptions\n    },\n    ref\n  ) => {\n    const {\n      extensions: extractedExtensions,\n      bubbleMenus,\n      commands: extractedCommands,\n    } = React.useMemo(\n      () => extractExtensionsAndBubbleMenus(extensions),\n      [extensions]\n    )\n\n    const editor = useTiptapEditor({\n      content,\n      extensions: toLatentArray(extractedExtensions),\n      ...editorOptions,\n    })\n\n    // Merge base registry with extension commands\n    const mergedRegistry = React.useMemo(() => {\n      if (extractedCommands.length === 0) {\n        return registry\n      }\n      const merged = createEditorRegistry<Editor>()\n      merged.extend(registry)\n      merged.registerMany(extractedCommands)\n      return merged\n    }, [registry, extractedCommands])\n\n    const contextValue = React.useMemo<EditorContextValue>(\n      () => ({ editor, registry: mergedRegistry }),\n      [editor, mergedRegistry]\n    )\n\n    return (\n      <EditorContext.Provider value={contextValue}>\n        <div\n          ref={ref}\n          className={cn(\"relative\", className)}\n          data-editor-root=\"\"\n        >\n          {children}\n          {bubbleMenus.map((menu, index) => (\n            <menu.component key={index} {...menu.props} />\n          ))}\n        </div>\n      </EditorContext.Provider>\n    )\n  }\n)\nEditorProvider.displayName = \"EditorProvider\"\n\n// =============================================================================\n// EditorContent\n// =============================================================================\n\nexport interface EditorContentProps extends Omit<\n  React.ComponentProps<typeof TiptapEditorContent>,\n  \"editor\"\n> {}\n\nconst EditorContent = React.forwardRef<HTMLDivElement, EditorContentProps>(\n  ({ className, ...props }, ref) => {\n    const { editor } = useEditor()\n\n    if (!editor) return null\n\n    return (\n      <TiptapEditorContent\n        ref={ref}\n        editor={editor}\n        className={cn(\n          \"w-full\",\n          \"[&>*]:outline-none\",\n          // Inline code styles\n          \"[&_.ProseMirror_code]:bg-muted\",\n          \"[&_.ProseMirror_code]:rounded\",\n          \"[&_.ProseMirror_code]:px-1.5\",\n          \"[&_.ProseMirror_code]:py-0.5\",\n          \"[&_.ProseMirror_code]:font-mono\",\n          \"[&_.ProseMirror_code]:text-[0.875em]\",\n          // Task list styles\n          \"[&_.ProseMirror_ul[data-type=taskList]]:list-none\",\n          \"[&_.ProseMirror_ul[data-type=taskList]]:pl-0\",\n          \"[&_.ProseMirror_ul[data-type=taskList]]:my-2\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li]:flex\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li]:items-start\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li]:gap-2\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li]:my-1\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li>label]:shrink-0\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li>label]:mt-0.5\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li>label>input[type=checkbox]]:cursor-pointer\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li>label>input[type=checkbox]]:size-4\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li>label>input[type=checkbox]]:accent-primary\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li>div]:flex-1\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li[data-checked=true]>div]:line-through\",\n          \"[&_.ProseMirror_ul[data-type=taskList]_li[data-checked=true]>div]:opacity-60\",\n          // Placeholder styles\n          EDITOR_PLACEHOLDER_CLASSES,\n          className\n        )}\n        {...props}\n      />\n    )\n  }\n)\nEditorContent.displayName = \"EditorContent\"\n\n// =============================================================================\n// EditorToolbar\n// =============================================================================\n\nexport interface EditorToolbarProps extends React.ComponentProps<\"div\"> {\n  orientation?: \"horizontal\" | \"vertical\"\n}\n\nconst EditorToolbar = React.forwardRef<HTMLDivElement, EditorToolbarProps>(\n  ({ className, orientation = \"horizontal\", children, ...props }, ref) => {\n    const { editor } = useEditor()\n\n    if (!editor) return null\n\n    return (\n      <div\n        ref={ref}\n        role=\"toolbar\"\n        aria-orientation={orientation}\n        className={cn(\n          \"flex items-center gap-1\",\n          orientation === \"vertical\" && \"flex-col\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n      </div>\n    )\n  }\n)\nEditorToolbar.displayName = \"EditorToolbar\"\n\n// =============================================================================\n// EditorButtonGroup\n// =============================================================================\n\nexport interface EditorButtonGroupProps extends React.ComponentProps<\"div\"> {}\n\nconst EditorButtonGroup = React.forwardRef<\n  HTMLDivElement,\n  EditorButtonGroupProps\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\"flex items-center gap-0.5\", className)}\n      {...props}\n    />\n  )\n})\nEditorButtonGroup.displayName = \"EditorButtonGroup\"\n\n// Alias\nconst EditorToolbarGroup = EditorButtonGroup\n\n// =============================================================================\n// EditorButton\n// =============================================================================\n\nexport interface EditorButtonProps extends React.ComponentProps<typeof Button> {\n  action: EditorActionKey\n  activeVariant?: \"default\" | \"secondary\" | \"outline\"\n}\n\nconst EditorButton = React.forwardRef<HTMLButtonElement, EditorButtonProps>(\n  (\n    { action, activeVariant = \"secondary\", className, children, ...props },\n    ref\n  ) => {\n    const { editor, registry } = useEditor()\n    const [updateKey, forceUpdate] = React.useReducer((x) => x + 1, 0)\n\n    React.useEffect(() => {\n      if (!editor) return\n\n      const handleUpdate = () => forceUpdate()\n      editor.on(\"transaction\", handleUpdate)\n\n      return () => {\n        editor.off(\"transaction\", handleUpdate)\n      }\n    }, [editor])\n\n    const isActive = React.useMemo(() => {\n      return registry.isActive(editor, action)\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [editor, registry, action, updateKey])\n\n    const canUse = registry.canExecute(editor, action)\n\n    const handleClick = () => {\n      registry.execute(editor, action)\n    }\n\n    const config = registry.get(action)\n\n    if (!editor) return null\n\n    return (\n      <Button\n        ref={ref}\n        type=\"button\"\n        variant={isActive ? activeVariant : \"ghost\"}\n        size=\"icon\"\n        disabled={!canUse}\n        onClick={handleClick}\n        aria-label={config?.label}\n        className={cn(\"size-8\", className)}\n        {...props}\n      >\n        {children}\n      </Button>\n    )\n  }\n)\nEditorButton.displayName = \"EditorButton\"\n\n// =============================================================================\n// EditorSeparator\n// =============================================================================\n\nexport interface EditorSeparatorProps extends React.ComponentProps<\"span\"> {}\n\nconst EditorSeparator = React.forwardRef<HTMLSpanElement, EditorSeparatorProps>(\n  ({ className, ...props }, ref) => {\n    const { editor } = useEditor()\n\n    if (!editor) return null\n\n    return (\n      <span\n        ref={ref}\n        className={cn(\"text-border mx-1 inline-flex items-center\", className)}\n        {...props}\n      >\n        |\n      </span>\n    )\n  }\n)\nEditorSeparator.displayName = \"EditorSeparator\"\n\n// =============================================================================\n// EditorDropdown Context\n// =============================================================================\n\ninterface EditorDropdownContextValue {\n  sharedConfigs: EditorActionConfig<Editor>[]\n}\n\nconst EditorDropdownContext =\n  React.createContext<EditorDropdownContextValue | null>(null)\n\n// =============================================================================\n// EditorDropdown\n// =============================================================================\n\nexport interface EditorDropdownProps extends React.ComponentProps<\n  typeof DropdownMenu\n> {\n  actions: EditorActionKey[]\n}\n\nconst EditorDropdown = React.forwardRef<HTMLButtonElement, EditorDropdownProps>(\n  ({ actions, children, ...props }, _ref) => {\n    const { editor, registry } = useEditor()\n\n    const handleChangeAction = (key: string) => {\n      registry.execute(editor, key)\n    }\n\n    const filteredConfigs = actions\n      .map((action) => registry.get(action))\n      .filter((c): c is EditorActionConfig<Editor> => Boolean(c))\n\n    const contextValue = React.useMemo<EditorDropdownContextValue>(\n      () => ({ sharedConfigs: filteredConfigs }),\n      [filteredConfigs]\n    )\n\n    if (!editor) return null\n\n    return (\n      <EditorDropdownContext.Provider value={contextValue}>\n        <DropdownMenu {...props}>\n          <DropdownMenuTrigger asChild>\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              className=\"shadow-none\"\n              aria-label=\"Open blocks menu\"\n            >\n              {children}\n              <ChevronDown className=\"text-muted-foreground ml-1 size-3\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContent className=\"pb-2\">\n            <ScrollArea\n              style={{\n                height: Math.min(filteredConfigs.length * 56, 300),\n              }}\n              className=\"max-h-[300px] overflow-auto\"\n            >\n              {filteredConfigs.map((item) => (\n                <DropdownMenuItem\n                  key={item.key}\n                  onClick={() => handleChangeAction(item.key)}\n                >\n                  <div\n                    className=\"border-border bg-background flex size-8 items-center justify-center rounded-lg border\"\n                    aria-hidden=\"true\"\n                  >\n                    {item.icon && (\n                      <item.icon\n                        size={16}\n                        strokeWidth={2}\n                        className=\"opacity-60\"\n                      />\n                    )}\n                  </div>\n                  <div>\n                    <div className=\"text-sm font-medium\">{item.label}</div>\n                    {item.description && (\n                      <div className=\"text-muted-foreground text-xs\">\n                        {item.description}\n                      </div>\n                    )}\n                  </div>\n                </DropdownMenuItem>\n              ))}\n            </ScrollArea>\n          </DropdownMenuContent>\n        </DropdownMenu>\n      </EditorDropdownContext.Provider>\n    )\n  }\n)\nEditorDropdown.displayName = \"EditorDropdown\"\n\n// =============================================================================\n// EditorLabel\n// =============================================================================\n\nexport interface EditorLabelProps extends React.ComponentProps<\"span\"> {\n  action?: string\n  pattern?: \":icon :label\" | \":label\" | \":label :icon\" | \":icon\"\n}\n\nconst EditorLabel = React.forwardRef<HTMLSpanElement, EditorLabelProps>(\n  ({ className, action, pattern = \":label\", ...props }, ref) => {\n    const dropdownCtx = React.useContext(EditorDropdownContext)\n    const { editor, registry } = useEditor()\n\n    const activeActions =\n      useEditorState({\n        editor,\n        selector: ({ editor: e }) => (e ? registry.getActiveKeys(e) : []),\n      }) ?? []\n\n    const configs = React.useMemo(() => {\n      if (action) {\n        const config = registry.get(action)\n        return config ? [config] : []\n      }\n\n      const filteredActions = dropdownCtx?.sharedConfigs?.length\n        ? activeActions.filter((a) =>\n            dropdownCtx.sharedConfigs.some((c) => c.key === a)\n          )\n        : activeActions\n\n      return filteredActions\n        .map((key) => registry.get(key))\n        .filter((c): c is EditorActionConfig<Editor> => Boolean(c))\n    }, [action, activeActions, dropdownCtx, registry])\n\n    const renderConfig = (config: EditorActionConfig<Editor>) => {\n      switch (pattern) {\n        case \":icon :label\":\n          return (\n            <React.Fragment key={config.key}>\n              {config.icon && <config.icon className=\"size-4\" />}\n              {config.label}\n            </React.Fragment>\n          )\n        case \":icon\":\n          return (\n            <React.Fragment key={config.key}>\n              {config.icon && <config.icon className=\"size-4\" />}\n            </React.Fragment>\n          )\n        case \":label :icon\":\n          return (\n            <React.Fragment key={config.key}>\n              {config.label}\n              {config.icon && <config.icon className=\"size-4\" />}\n            </React.Fragment>\n          )\n        default:\n          return config.label\n      }\n    }\n\n    const content =\n      configs.length > 0\n        ? configs.map(renderConfig)\n        : dropdownCtx?.sharedConfigs?.[0]\n          ? renderConfig(dropdownCtx.sharedConfigs[0])\n          : null\n\n    return (\n      <span\n        ref={ref}\n        className={cn(\"inline-flex items-center gap-2\", className)}\n        {...props}\n      >\n        {content}\n      </span>\n    )\n  }\n)\nEditorLabel.displayName = \"EditorLabel\"\n\n// =============================================================================\n// EditorFloatingMenu\n// =============================================================================\n\nexport interface EditorFloatingMenuProps extends Omit<\n  React.ComponentProps<typeof FloatingMenu>,\n  \"editor\"\n> {}\n\nfunction EditorFloatingMenu({ children, ...props }: EditorFloatingMenuProps) {\n  const { editor } = useEditor()\n\n  if (!editor) return null\n\n  return (\n    <FloatingMenu editor={editor} {...props}>\n      {children}\n    </FloatingMenu>\n  )\n}\n\n// =============================================================================\n// EditorBubbleMenu (Core Composition Component)\n// =============================================================================\n\nexport interface EditorBubbleMenuProps extends Omit<\n  React.ComponentProps<typeof BubbleMenu>,\n  \"editor\"\n> {}\n\nconst EditorBubbleMenu = React.forwardRef<\n  HTMLDivElement,\n  EditorBubbleMenuProps\n>(({ shouldShow, tippyOptions, className, children, ...props }, ref) => {\n  const { editor } = useEditor()\n\n  if (!editor) return null\n\n  return (\n    <BubbleMenu\n      {...props}\n      editor={editor}\n      tippyOptions={{\n        duration: 100,\n        placement: \"top\",\n        ...tippyOptions,\n      }}\n      shouldShow={shouldShow}\n      className={cn(\"w-fit\", className)}\n    >\n      <div ref={ref}>{children}</div>\n    </BubbleMenu>\n  )\n})\nEditorBubbleMenu.displayName = \"EditorBubbleMenu\"\n\n// =============================================================================\n// EditorBubbleMenuContent\n// =============================================================================\n\nexport interface EditorBubbleMenuContentProps extends React.ComponentProps<\"div\"> {}\n\nconst EditorBubbleMenuContent = React.forwardRef<\n  HTMLDivElement,\n  EditorBubbleMenuContentProps\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"bg-popover flex items-center gap-0.5 rounded-md border p-0.5 shadow-md\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nEditorBubbleMenuContent.displayName = \"EditorBubbleMenuContent\"\n\n// =============================================================================\n// EditorBubbleMenuGroup\n// =============================================================================\n\nexport interface EditorBubbleMenuGroupProps extends React.ComponentProps<\"div\"> {}\n\nconst EditorBubbleMenuGroup = React.forwardRef<\n  HTMLDivElement,\n  EditorBubbleMenuGroupProps\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\"flex items-center gap-0.5\", className)}\n      {...props}\n    />\n  )\n})\nEditorBubbleMenuGroup.displayName = \"EditorBubbleMenuGroup\"\n\n// =============================================================================\n// EditorBubbleMenuSeparator\n// =============================================================================\n\nexport interface EditorBubbleMenuSeparatorProps extends React.ComponentProps<\"div\"> {}\n\nconst EditorBubbleMenuSeparator = React.forwardRef<\n  HTMLDivElement,\n  EditorBubbleMenuSeparatorProps\n>(({ className, ...props }, ref) => {\n  return (\n    <div ref={ref} className={cn(\"bg-border h-4 w-px\", className)} {...props} />\n  )\n})\nEditorBubbleMenuSeparator.displayName = \"EditorBubbleMenuSeparator\"\n\n// =============================================================================\n// EditorBubbleMenuButton\n// =============================================================================\n\nexport interface EditorBubbleMenuButtonProps extends Omit<\n  React.ComponentProps<typeof Button>,\n  \"onClick\"\n> {\n  action?: string\n  isActive?: boolean\n  onAction?: () => void\n}\n\nconst EditorBubbleMenuButton = React.forwardRef<\n  HTMLButtonElement,\n  EditorBubbleMenuButtonProps\n>(\n  (\n    { action, isActive: isActiveProp, onAction, className, children, ...props },\n    ref\n  ) => {\n    const { editor, registry } = useEditor()\n    const [updateKey, forceUpdate] = React.useReducer((x) => x + 1, 0)\n\n    React.useEffect(() => {\n      if (!editor) return\n\n      const handleUpdate = () => forceUpdate()\n      editor.on(\"transaction\", handleUpdate)\n\n      return () => {\n        editor.off(\"transaction\", handleUpdate)\n      }\n    }, [editor])\n\n    const isActiveFromAction = React.useMemo(() => {\n      if (!action) return false\n      return registry.isActive(editor, action)\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [editor, registry, action, updateKey])\n\n    const isActive = isActiveProp ?? isActiveFromAction\n\n    const handleClick = () => {\n      if (onAction) {\n        onAction()\n        return\n      }\n      if (action) {\n        registry.execute(editor, action)\n      }\n    }\n\n    const config = action ? registry.get(action) : undefined\n    const canUse = action ? registry.canExecute(editor, action) : true\n\n    if (!editor) return null\n\n    return (\n      <Button\n        ref={ref}\n        type=\"button\"\n        variant={isActive ? \"secondary\" : \"ghost\"}\n        size=\"sm\"\n        disabled={!canUse}\n        onClick={handleClick}\n        aria-label={config?.label}\n        className={cn(\"h-7 w-7 p-0\", className)}\n        {...props}\n      >\n        {children}\n      </Button>\n    )\n  }\n)\nEditorBubbleMenuButton.displayName = \"EditorBubbleMenuButton\"\n\n// =============================================================================\n// EditorBubbleMenuPopover Context\n// =============================================================================\n\ninterface EditorBubbleMenuPopoverContextValue {\n  open: boolean\n  setOpen: (open: boolean) => void\n}\n\nconst EditorBubbleMenuPopoverContext =\n  React.createContext<EditorBubbleMenuPopoverContextValue | null>(null)\n\nfunction useEditorBubbleMenuPopover() {\n  const ctx = React.useContext(EditorBubbleMenuPopoverContext)\n  if (!ctx) {\n    throw new Error(\n      \"useEditorBubbleMenuPopover must be used within EditorBubbleMenuPopover\"\n    )\n  }\n  return ctx\n}\n\n// =============================================================================\n// EditorBubbleMenuPopover\n// =============================================================================\n\nexport interface EditorBubbleMenuPopoverProps {\n  children: React.ReactNode\n  open?: boolean\n  defaultOpen?: boolean\n  onOpenChange?: (open: boolean) => void\n}\n\nfunction EditorBubbleMenuPopover({\n  children,\n  open: controlledOpen,\n  defaultOpen = false,\n  onOpenChange,\n}: EditorBubbleMenuPopoverProps) {\n  const [internalOpen, setInternalOpen] = React.useState(defaultOpen)\n\n  const isControlled = controlledOpen !== undefined\n  const open = isControlled ? controlledOpen : internalOpen\n\n  const setOpen = React.useCallback(\n    (nextOpen: boolean) => {\n      if (!isControlled) {\n        setInternalOpen(nextOpen)\n      }\n      onOpenChange?.(nextOpen)\n    },\n    [isControlled, onOpenChange]\n  )\n\n  const contextValue = React.useMemo(() => ({ open, setOpen }), [open, setOpen])\n\n  return (\n    <EditorBubbleMenuPopoverContext.Provider value={contextValue}>\n      <div className=\"relative\">{children}</div>\n    </EditorBubbleMenuPopoverContext.Provider>\n  )\n}\nEditorBubbleMenuPopover.displayName = \"EditorBubbleMenuPopover\"\n\n// =============================================================================\n// EditorBubbleMenuPopoverTrigger\n// =============================================================================\n\nexport interface EditorBubbleMenuPopoverTriggerProps extends React.ComponentProps<\"button\"> {\n  asChild?: boolean\n}\n\nconst EditorBubbleMenuPopoverTrigger = React.forwardRef<\n  HTMLButtonElement,\n  EditorBubbleMenuPopoverTriggerProps\n>(({ asChild, onClick, children, ...props }, ref) => {\n  const { open, setOpen } = useEditorBubbleMenuPopover()\n\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    setOpen(!open)\n    onClick?.(e)\n  }\n\n  if (asChild && React.isValidElement(children)) {\n    return React.cloneElement(\n      children as React.ReactElement<{\n        onClick?: (e: React.MouseEvent<HTMLButtonElement>) => void\n        \"data-state\"?: string\n      }>,\n      {\n        onClick: (e: React.MouseEvent<HTMLButtonElement>) => {\n          handleClick(e)\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ;(children as any).props?.onClick?.(e)\n        },\n        \"data-state\": open ? \"open\" : \"closed\",\n      }\n    )\n  }\n\n  return (\n    <button\n      ref={ref}\n      type=\"button\"\n      data-state={open ? \"open\" : \"closed\"}\n      onClick={handleClick}\n      {...props}\n    >\n      {children}\n    </button>\n  )\n})\nEditorBubbleMenuPopoverTrigger.displayName = \"EditorBubbleMenuPopoverTrigger\"\n\n// =============================================================================\n// EditorBubbleMenuPopoverContent\n// =============================================================================\n\nexport interface EditorBubbleMenuPopoverContentProps extends React.ComponentProps<\"div\"> {\n  align?: \"start\" | \"center\" | \"end\"\n  side?: \"top\" | \"bottom\"\n  sideOffset?: number\n}\n\nconst EditorBubbleMenuPopoverContent = React.forwardRef<\n  HTMLDivElement,\n  EditorBubbleMenuPopoverContentProps\n>(\n  (\n    { className, align = \"start\", side = \"bottom\", sideOffset = 4, ...props },\n    ref\n  ) => {\n    const { open, setOpen } = useEditorBubbleMenuPopover()\n    const contentRef = React.useRef<HTMLDivElement>(null)\n\n    React.useEffect(() => {\n      if (!open) return\n\n      const handleKeyDown = (e: KeyboardEvent) => {\n        if (e.key === \"Escape\") {\n          setOpen(false)\n        }\n      }\n\n      document.addEventListener(\"keydown\", handleKeyDown)\n      return () => document.removeEventListener(\"keydown\", handleKeyDown)\n    }, [open, setOpen])\n\n    React.useEffect(() => {\n      if (open && contentRef.current) {\n        const firstInput = contentRef.current.querySelector(\"input\")\n        if (firstInput) {\n          firstInput.focus()\n        }\n      }\n    }, [open])\n\n    if (!open) return null\n\n    const alignClasses = {\n      start: \"left-0\",\n      center: \"left-1/2 -translate-x-1/2\",\n      end: \"right-0\",\n    }\n\n    const sideClasses = {\n      top: \"bottom-full mb-1\",\n      bottom: \"top-full mt-1\",\n    }\n\n    return (\n      <div\n        ref={(node) => {\n          contentRef.current = node\n          if (typeof ref === \"function\") ref(node)\n          else if (ref) ref.current = node\n        }}\n        className={cn(\n          \"bg-popover text-popover-foreground absolute z-50 min-w-[200px] rounded-md border p-2 shadow-md\",\n          \"animate-in fade-in-0 zoom-in-95\",\n          alignClasses[align],\n          sideClasses[side],\n          className\n        )}\n        style={{\n          marginTop: side === \"bottom\" ? sideOffset : undefined,\n          marginBottom: side === \"top\" ? sideOffset : undefined,\n        }}\n        {...props}\n      />\n    )\n  }\n)\nEditorBubbleMenuPopoverContent.displayName = \"EditorBubbleMenuPopoverContent\"\n\n// =============================================================================\n// EditorBubbleMenuForm Context\n// =============================================================================\n\ninterface EditorBubbleMenuFormContextValue {\n  values: Record<string, string>\n  setValue: (name: string, value: string) => void\n  submit: () => void\n  cancel: () => void\n}\n\nconst EditorBubbleMenuFormContext =\n  React.createContext<EditorBubbleMenuFormContextValue | null>(null)\n\nfunction useEditorBubbleMenuForm() {\n  const ctx = React.useContext(EditorBubbleMenuFormContext)\n  if (!ctx) {\n    throw new Error(\n      \"useEditorBubbleMenuForm must be used within EditorBubbleMenuForm\"\n    )\n  }\n  return ctx\n}\n\n// =============================================================================\n// EditorBubbleMenuForm\n// =============================================================================\n\nexport interface EditorBubbleMenuFormProps extends Omit<\n  React.ComponentProps<\"form\">,\n  \"onSubmit\"\n> {\n  onSubmit?: (values: Record<string, string>, editor: Editor) => void\n  onCancel?: () => void\n  closeOnSubmit?: boolean\n}\n\nconst EditorBubbleMenuForm = React.forwardRef<\n  HTMLFormElement,\n  EditorBubbleMenuFormProps\n>(\n  (\n    {\n      onSubmit: onSubmitProp,\n      onCancel,\n      closeOnSubmit = true,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const { editor } = useEditor()\n    const popoverCtx = React.useContext(EditorBubbleMenuPopoverContext)\n    const [values, setValues] = React.useState<Record<string, string>>({})\n\n    const setValue = React.useCallback((name: string, value: string) => {\n      setValues((prev) => ({ ...prev, [name]: value }))\n    }, [])\n\n    const submit = React.useCallback(() => {\n      onSubmitProp?.(values, editor!)\n      if (closeOnSubmit && popoverCtx) {\n        popoverCtx.setOpen(false)\n      }\n    }, [values, onSubmitProp, closeOnSubmit, popoverCtx])\n\n    const cancel = React.useCallback(() => {\n      onCancel?.()\n      popoverCtx?.setOpen(false)\n    }, [onCancel, popoverCtx])\n\n    const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n      e.preventDefault()\n      submit()\n    }\n\n    const contextValue = React.useMemo(\n      () => ({ values, setValue, submit, cancel }),\n      [values, setValue, submit, cancel]\n    )\n\n    return (\n      <EditorBubbleMenuFormContext.Provider value={contextValue}>\n        <form\n          ref={ref}\n          onSubmit={handleSubmit}\n          className={cn(\"flex flex-col gap-2\", className)}\n          {...props}\n        >\n          {children}\n        </form>\n      </EditorBubbleMenuFormContext.Provider>\n    )\n  }\n)\nEditorBubbleMenuForm.displayName = \"EditorBubbleMenuForm\"\n\n// =============================================================================\n// EditorBubbleMenuInput\n// =============================================================================\n\nexport type EditorBubbleMenuInputBinding =\n  | string\n  | ((editor: Editor) => string | undefined)\n\nexport interface EditorBubbleMenuInputProps extends Omit<\n  React.ComponentProps<typeof Input>,\n  \"name\" | \"value\" | \"onChange\"\n> {\n  name: string\n  binding?: EditorBubbleMenuInputBinding\n  onValueChange?: (value: string) => void\n}\n\nconst EditorBubbleMenuInput = React.forwardRef<\n  HTMLInputElement,\n  EditorBubbleMenuInputProps\n>(({ name, binding, onValueChange, onKeyDown, className, ...props }, ref) => {\n  const { editor } = useEditor()\n  const formCtx = React.useContext(EditorBubbleMenuFormContext)\n  const [localValue, setLocalValue] = React.useState(\"\")\n\n  // Use ref for setValue to avoid dependency issues\n  const setValueRef = React.useRef(formCtx?.setValue)\n  setValueRef.current = formCtx?.setValue\n\n  // Get initial value from binding - only run once when popover opens\n  React.useEffect(() => {\n    if (!editor || !binding) return\n\n    let initialValue: string | undefined\n\n    if (typeof binding === \"function\") {\n      initialValue = binding(editor)\n    } else {\n      // Parse dot notation: \"link.href\" -> mark=\"link\", attr=\"href\"\n      const [mark, attr] = binding.split(\".\")\n      if (mark && attr) {\n        const attrs = editor.getAttributes(mark)\n        initialValue = attrs?.[attr] as string | undefined\n      } else {\n        // Single value means it's just a mark name, get all attributes\n        initialValue = editor.getAttributes(binding)?.[binding] as\n          | string\n          | undefined\n      }\n    }\n\n    const value = initialValue ?? \"\"\n    setLocalValue(value)\n    setValueRef.current?.(name, value)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor, binding, name])\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value\n    setLocalValue(newValue)\n    formCtx?.setValue(name, newValue)\n    onValueChange?.(newValue)\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === \"Enter\" && formCtx) {\n      e.preventDefault()\n      formCtx.submit()\n    }\n    onKeyDown?.(e)\n  }\n\n  return (\n    <Input\n      ref={ref}\n      name={name}\n      value={localValue}\n      onChange={handleChange}\n      onKeyDown={handleKeyDown}\n      className={cn(\"h-8 text-sm\", className)}\n      {...props}\n    />\n  )\n})\nEditorBubbleMenuInput.displayName = \"EditorBubbleMenuInput\"\n\n// =============================================================================\n// EditorBubbleMenuFormActions\n// =============================================================================\n\nexport interface EditorBubbleMenuFormActionsProps extends React.ComponentProps<\"div\"> {}\n\nconst EditorBubbleMenuFormActions = React.forwardRef<\n  HTMLDivElement,\n  EditorBubbleMenuFormActionsProps\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\"flex items-center justify-end gap-1\", className)}\n      {...props}\n    />\n  )\n})\nEditorBubbleMenuFormActions.displayName = \"EditorBubbleMenuFormActions\"\n\n// =============================================================================\n// EditorBubbleMenuFormSubmit\n// =============================================================================\n\nexport interface EditorBubbleMenuFormSubmitProps extends Omit<\n  React.ComponentProps<typeof Button>,\n  \"type\" | \"onClick\"\n> {}\n\nconst EditorBubbleMenuFormSubmit = React.forwardRef<\n  HTMLButtonElement,\n  EditorBubbleMenuFormSubmitProps\n>(({ className, children, ...props }, ref) => {\n  const { submit } = useEditorBubbleMenuForm()\n\n  return (\n    <Button\n      ref={ref}\n      type=\"button\"\n      variant=\"ghost\"\n      size=\"sm\"\n      onClick={submit}\n      className={cn(\"h-7 w-7 p-0\", className)}\n      {...props}\n    >\n      {children ?? <Check className=\"size-3.5\" />}\n    </Button>\n  )\n})\nEditorBubbleMenuFormSubmit.displayName = \"EditorBubbleMenuFormSubmit\"\n\n// =============================================================================\n// EditorBubbleMenuFormCancel\n// =============================================================================\n\nexport interface EditorBubbleMenuFormCancelProps extends Omit<\n  React.ComponentProps<typeof Button>,\n  \"type\" | \"onClick\"\n> {}\n\nconst EditorBubbleMenuFormCancel = React.forwardRef<\n  HTMLButtonElement,\n  EditorBubbleMenuFormCancelProps\n>(({ className, children, ...props }, ref) => {\n  const { cancel } = useEditorBubbleMenuForm()\n\n  return (\n    <Button\n      ref={ref}\n      type=\"button\"\n      variant=\"ghost\"\n      size=\"sm\"\n      onClick={cancel}\n      className={cn(\"h-7 w-7 p-0\", className)}\n      {...props}\n    >\n      {children ?? <Link2Off className=\"size-3.5\" />}\n    </Button>\n  )\n})\nEditorBubbleMenuFormCancel.displayName = \"EditorBubbleMenuFormCancel\"\n\n// =============================================================================\n// EditorBubbleMenuDropdown (Radix-based Dropdown System)\n// =============================================================================\n\nconst EditorBubbleMenuDropdownRoot = DropdownMenuPrimitive.Root\n\nexport interface EditorBubbleMenuDropdownProps extends React.ComponentProps<\n  typeof DropdownMenuPrimitive.Root\n> {}\n\nfunction EditorBubbleMenuDropdown({\n  children,\n  ...props\n}: EditorBubbleMenuDropdownProps) {\n  return (\n    <EditorBubbleMenuDropdownRoot {...props}>\n      {children}\n    </EditorBubbleMenuDropdownRoot>\n  )\n}\nEditorBubbleMenuDropdown.displayName = \"EditorBubbleMenuDropdown\"\n\n// =============================================================================\n// EditorBubbleMenuDropdownTrigger\n// =============================================================================\n\nexport interface EditorBubbleMenuDropdownTriggerProps extends React.ComponentProps<\n  typeof DropdownMenuPrimitive.Trigger\n> {}\n\nconst EditorBubbleMenuDropdownTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Trigger>,\n  EditorBubbleMenuDropdownTriggerProps\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.Trigger\n    ref={ref}\n    asChild\n    className={cn(\"outline-none\", className)}\n    {...props}\n  >\n    {children}\n  </DropdownMenuPrimitive.Trigger>\n))\nEditorBubbleMenuDropdownTrigger.displayName = \"EditorBubbleMenuDropdownTrigger\"\n\n// =============================================================================\n// EditorBubbleMenuDropdownContent\n// =============================================================================\n\nexport interface EditorBubbleMenuDropdownContentProps extends React.ComponentProps<\n  typeof DropdownMenuPrimitive.Content\n> {\n  portal?: boolean\n}\n\nconst EditorBubbleMenuDropdownContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  EditorBubbleMenuDropdownContentProps\n>(({ className, portal = false, sideOffset = 4, ...props }, ref) => {\n  const Portal = portal ? DropdownMenuPrimitive.Portal : React.Fragment\n  return (\n    <Portal>\n      <DropdownMenuPrimitive.Content\n        ref={ref}\n        sideOffset={sideOffset}\n        className={cn(\n          \"bg-popover text-popover-foreground z-50 min-w-[8rem] overflow-hidden rounded-lg border p-1.5 shadow-md\",\n          \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n          className\n        )}\n        {...props}\n      />\n    </Portal>\n  )\n})\nEditorBubbleMenuDropdownContent.displayName = \"EditorBubbleMenuDropdownContent\"\n\n// =============================================================================\n// EditorBubbleMenuDropdownItem\n// =============================================================================\n\nexport interface EditorBubbleMenuDropdownItemProps extends React.ComponentProps<\n  typeof DropdownMenuPrimitive.Item\n> {\n  inset?: boolean\n}\n\nconst EditorBubbleMenuDropdownItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  EditorBubbleMenuDropdownItemProps\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default items-center gap-2 rounded-md px-2 py-1.5 text-sm transition-colors outline-none select-none\",\n      \"focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      \"[&>svg]:size-4 [&>svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nEditorBubbleMenuDropdownItem.displayName = \"EditorBubbleMenuDropdownItem\"\n\n// =============================================================================\n// EditorBubbleMenuDropdownSub\n// =============================================================================\n\nconst EditorBubbleMenuDropdownSub = DropdownMenuPrimitive.Sub\n\n// =============================================================================\n// EditorBubbleMenuDropdownSubTrigger\n// =============================================================================\n\nexport interface EditorBubbleMenuDropdownSubTriggerProps extends React.ComponentProps<\n  typeof DropdownMenuPrimitive.SubTrigger\n> {\n  inset?: boolean\n}\n\nconst EditorBubbleMenuDropdownSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  EditorBubbleMenuDropdownSubTriggerProps\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center gap-2 rounded-md px-2 py-1.5 text-sm outline-none select-none\",\n      \"focus:bg-accent data-[state=open]:bg-accent\",\n      \"[&>svg]:size-4 [&>svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto size-4\" />\n  </DropdownMenuPrimitive.SubTrigger>\n))\nEditorBubbleMenuDropdownSubTrigger.displayName =\n  \"EditorBubbleMenuDropdownSubTrigger\"\n\n// =============================================================================\n// EditorBubbleMenuDropdownSubContent\n// =============================================================================\n\nexport interface EditorBubbleMenuDropdownSubContentProps extends React.ComponentProps<\n  typeof DropdownMenuPrimitive.SubContent\n> {}\n\nconst EditorBubbleMenuDropdownSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  EditorBubbleMenuDropdownSubContentProps\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.SubContent\n      ref={ref}\n      className={cn(\n        \"bg-popover text-popover-foreground z-50 min-w-[8rem] overflow-hidden rounded-lg border p-1.5 shadow-lg\",\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n))\nEditorBubbleMenuDropdownSubContent.displayName =\n  \"EditorBubbleMenuDropdownSubContent\"\n\n// =============================================================================\n// EditorBubbleMenuDropdownSeparator\n// =============================================================================\n\nexport interface EditorBubbleMenuDropdownSeparatorProps extends React.ComponentProps<\n  typeof DropdownMenuPrimitive.Separator\n> {}\n\nconst EditorBubbleMenuDropdownSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  EditorBubbleMenuDropdownSeparatorProps\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"bg-muted -mx-1 my-1.5 h-px\", className)}\n    {...props}\n  />\n))\nEditorBubbleMenuDropdownSeparator.displayName =\n  \"EditorBubbleMenuDropdownSeparator\"\n\n// =============================================================================\n// EditorBubbleMenuDropdownLabel\n// =============================================================================\n\nexport interface EditorBubbleMenuDropdownLabelProps extends React.ComponentProps<\n  typeof DropdownMenuPrimitive.Label\n> {\n  inset?: boolean\n}\n\nconst EditorBubbleMenuDropdownLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  EditorBubbleMenuDropdownLabelProps\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"text-muted-foreground px-2 py-1.5 text-xs font-medium\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nEditorBubbleMenuDropdownLabel.displayName = \"EditorBubbleMenuDropdownLabel\"\n\n// =============================================================================\n// EditorBubbleMenuDropdownGroup\n// =============================================================================\n\nexport interface EditorBubbleMenuDropdownGroupProps extends React.ComponentProps<\n  typeof DropdownMenuPrimitive.Group\n> {}\n\nconst EditorBubbleMenuDropdownGroup = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Group>,\n  EditorBubbleMenuDropdownGroupProps\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Group\n    ref={ref}\n    className={cn(\"\", className)}\n    {...props}\n  />\n))\nEditorBubbleMenuDropdownGroup.displayName = \"EditorBubbleMenuDropdownGroup\"\n\n// =============================================================================\n// Hooks\n// =============================================================================\n\nexport function useEditorIsActive(action: string): boolean {\n  const { editor, registry } = useEditor()\n\n  return React.useMemo(() => {\n    return registry.isActive(editor, action)\n  }, [editor, registry, action])\n}\n\nexport function useEditorCurrentActions(): string[] {\n  const { editor, registry } = useEditor()\n  return React.useMemo(() => registry.getActiveKeys(editor), [editor, registry])\n}\n\nexport function toLatentArray<T>(...inputs: NestedArray<T>[]): T[] {\n  const out: T[] = []\n\n  // Stack holds items to process. We push in reverse so we can pop and keep order.\n  const stack: NestedArray<T>[] = []\n  for (let i = inputs.length - 1; i >= 0; i--) stack.push(inputs[i])\n\n  while (stack.length) {\n    const cur = stack.pop() as NestedArray<T>\n\n    if (Array.isArray(cur)) {\n      // Push children in reverse to preserve original order.\n      for (let i = cur.length - 1; i >= 0; i--) {\n        stack.push(cur[i] as NestedArray<T>)\n      }\n    } else {\n      out.push(cur)\n    }\n  }\n\n  return out\n}\n\n// =============================================================================\n// Exports\n// =============================================================================\n\nexport {\n  EditorBubbleMenu,\n  EditorBubbleMenuButton,\n  EditorBubbleMenuContent,\n  EditorBubbleMenuDropdown,\n  EditorBubbleMenuDropdownContent,\n  EditorBubbleMenuDropdownGroup,\n  EditorBubbleMenuDropdownItem,\n  EditorBubbleMenuDropdownLabel,\n  EditorBubbleMenuDropdownSeparator,\n  EditorBubbleMenuDropdownSub,\n  EditorBubbleMenuDropdownSubContent,\n  EditorBubbleMenuDropdownSubTrigger,\n  EditorBubbleMenuDropdownTrigger,\n  EditorBubbleMenuForm,\n  EditorBubbleMenuFormActions,\n  EditorBubbleMenuFormCancel,\n  EditorBubbleMenuFormSubmit,\n  EditorBubbleMenuGroup,\n  EditorBubbleMenuInput,\n  EditorBubbleMenuLink,\n  EditorBubbleMenuPopover,\n  EditorBubbleMenuPopoverContent,\n  EditorBubbleMenuPopoverTrigger,\n  EditorBubbleMenuSeparator,\n  EditorButton,\n  EditorButtonGroup,\n  EditorContent,\n  EditorDropdown,\n  EditorFloatingMenu,\n  EditorLabel,\n  EditorProvider,\n  EditorSeparator,\n  EditorToolbar,\n  EditorToolbarGroup,\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor.d.ts",
      "content": "// Auto-generated by scripts/generate-editor-types.ts\n// Do not edit manually - regenerate with: pnpm run editor:types\n\n/**\n * Union type of all registered editor action keys.\n * Used for autocomplete in EditorButton and EditorDropdown components.\n */\nexport type EditorActionKey =\n  | \"addColumnAfter\"\n  | \"addColumnBefore\"\n  | \"addRowAfter\"\n  | \"addRowBefore\"\n  | \"blockquote\"\n  | \"bold\"\n  | \"bulletList\"\n  | \"center\"\n  | \"code\"\n  | \"codeBlock\"\n  | \"deleteColumn\"\n  | \"deleteRow\"\n  | \"deleteTable\"\n  | \"divider\"\n  | \"goToNextCell\"\n  | \"goToPreviousCell\"\n  | \"heading1\"\n  | \"heading2\"\n  | \"heading3\"\n  | \"heading4\"\n  | \"heading5\"\n  | \"heading6\"\n  | \"highlight\"\n  | \"image\"\n  | \"insertTable\"\n  | \"italic\"\n  | \"justify\"\n  | \"left\"\n  | \"mergeCells\"\n  | \"mergeOrSplit\"\n  | \"orderedList\"\n  | \"paragraph\"\n  | \"redo\"\n  | \"right\"\n  | \"setLink\"\n  | \"splitCell\"\n  | \"strike\"\n  | \"taskList\"\n  | \"toggleHeaderCell\"\n  | \"toggleHeaderColumn\"\n  | \"toggleHeaderRow\"\n  | \"underline\"\n  | \"undo\"\n  | \"unsetLink\"\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-code-block.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport type { Editor } from \"@tiptap/react\"\nimport { Extension } from \"@tiptap/core\"\nimport CodeBlockLowlight from \"@tiptap/extension-code-block-lowlight\"\nimport { BubbleMenu } from \"@tiptap/react\"\nimport { all, createLowlight } from \"lowlight\"\nimport { EditorContext, createEditorExtension } from \"./editor\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport { cn } from \"@/lib/utils\"\nimport { Check, ChevronDown, ClipboardCopy, Code2, Trash2 } from \"lucide-react\"\n\n// =============================================================================\n// Constants\n// =============================================================================\n\ninterface CodeBlockLanguage {\n  name: string\n  value: string\n}\n\nexport const CODEBLOCK_LANGUAGES: CodeBlockLanguage[] = [\n  { name: \"Plain Text\", value: \"plaintext\" },\n  { name: \"JavaScript\", value: \"javascript\" },\n  { name: \"TypeScript\", value: \"typescript\" },\n  { name: \"JSX\", value: \"jsx\" },\n  { name: \"TSX\", value: \"tsx\" },\n  { name: \"HTML\", value: \"html\" },\n  { name: \"CSS\", value: \"css\" },\n  { name: \"SCSS\", value: \"scss\" },\n  { name: \"JSON\", value: \"json\" },\n  { name: \"Markdown\", value: \"markdown\" },\n  { name: \"Python\", value: \"python\" },\n  { name: \"Java\", value: \"java\" },\n  { name: \"C\", value: \"c\" },\n  { name: \"C++\", value: \"cpp\" },\n  { name: \"C#\", value: \"csharp\" },\n  { name: \"Go\", value: \"go\" },\n  { name: \"Rust\", value: \"rust\" },\n  { name: \"Ruby\", value: \"ruby\" },\n  { name: \"PHP\", value: \"php\" },\n  { name: \"Swift\", value: \"swift\" },\n  { name: \"Kotlin\", value: \"kotlin\" },\n  { name: \"Scala\", value: \"scala\" },\n  { name: \"SQL\", value: \"sql\" },\n  { name: \"GraphQL\", value: \"graphql\" },\n  { name: \"Shell\", value: \"bash\" },\n  { name: \"PowerShell\", value: \"powershell\" },\n  { name: \"Docker\", value: \"dockerfile\" },\n  { name: \"YAML\", value: \"yaml\" },\n  { name: \"XML\", value: \"xml\" },\n  { name: \"Diff\", value: \"diff\" },\n]\n\nexport type CodeBlockLanguageValue =\n  (typeof CODEBLOCK_LANGUAGES)[number][\"value\"]\n\n// =============================================================================\n// Lowlight instance with all languages\n// =============================================================================\n\nconst lowlight = createLowlight(all)\n\n// =============================================================================\n// EditorCodeBlockExtension\n// =============================================================================\n\nexport interface EditorCodeBlockOptions {\n  defaultLanguage?: CodeBlockLanguageValue\n  HTMLAttributes?: Record<string, unknown>\n}\n\nconst EditorCodeBlockNode = Extension.create({\n  name: \"codeBlockLowlight\",\n  addExtensions() {\n    return [\n      CodeBlockLowlight.configure({ lowlight, defaultLanguage: \"plaintext\" }),\n    ]\n  },\n})\n\nexport const EditorCodeBlockExtension = createEditorExtension({\n  extension: EditorCodeBlockNode,\n  bubbleMenu: EditorBubbleMenuCodeBlock,\n  commands: [\n    {\n      key: \"codeBlock\",\n      icon: Code2,\n      label: \"Code Block\",\n      description: \"Add a code block\",\n      execute: (editor) => editor.chain().focus().toggleCodeBlock().run(),\n      canExecute: (editor) =>\n        editor.can().chain().focus().toggleCodeBlock().run(),\n      isActive: (editor) => editor.isActive(\"codeBlock\"),\n    },\n  ],\n})\n\n// =============================================================================\n// Syntax Highlighting Styles (GitHub Dark-inspired)\n// Injected into document on first use\n// =============================================================================\n\nexport const CODEBLOCK_STYLES = `\n  /* ==========================================================================\n     Syntax Highlighting Theme (GitHub Dark-inspired)\n     ========================================================================== */\n  /* Comments */\n  .ProseMirror .hljs-comment,\n  .ProseMirror .hljs-quote {\n    color: hsl(215 12% 50%);\n    font-style: italic;\n  }\n\n  /* Keywords & Tags */\n  .ProseMirror .hljs-keyword,\n  .ProseMirror .hljs-selector-tag {\n    color: hsl(350 89% 72%);\n  }\n\n  /* Strings & Regex */\n  .ProseMirror .hljs-string,\n  .ProseMirror .hljs-regexp,\n  .ProseMirror .hljs-attribute,\n  .ProseMirror .hljs-template-variable,\n  .ProseMirror .hljs-variable.language_ {\n    color: hsl(212 97% 81%);\n  }\n\n  /* Numbers */\n  .ProseMirror .hljs-number,\n  .ProseMirror .hljs-literal {\n    color: hsl(212 97% 81%);\n  }\n\n  /* Functions & Classes */\n  .ProseMirror .hljs-title,\n  .ProseMirror .hljs-title.class_,\n  .ProseMirror .hljs-title.function_ {\n    color: hsl(260 83% 79%);\n  }\n\n  /* Built-in & Types */\n  .ProseMirror .hljs-built_in,\n  .ProseMirror .hljs-type {\n    color: hsl(29 67% 75%);\n  }\n\n  /* Variables & Params */\n  .ProseMirror .hljs-variable,\n  .ProseMirror .hljs-params {\n    color: hsl(210 14% 93%);\n  }\n\n  /* Properties & Attributes */\n  .ProseMirror .hljs-attr,\n  .ProseMirror .hljs-property {\n    color: hsl(212 97% 81%);\n  }\n\n  /* Symbols & Bullets */\n  .ProseMirror .hljs-symbol,\n  .ProseMirror .hljs-bullet {\n    color: hsl(350 89% 72%);\n  }\n\n  /* Meta & Preprocessor */\n  .ProseMirror .hljs-meta,\n  .ProseMirror .hljs-meta .hljs-keyword {\n    color: hsl(350 89% 72%);\n  }\n\n  /* Links */\n  .ProseMirror .hljs-link {\n    color: hsl(212 97% 81%);\n    text-decoration: underline;\n  }\n\n  /* Deletion (diff) */\n  .ProseMirror .hljs-deletion {\n    color: hsl(350 89% 72%);\n    background: hsl(350 89% 72% / 0.15);\n  }\n\n  /* Addition (diff) */\n  .ProseMirror .hljs-addition {\n    color: hsl(139 66% 69%);\n    background: hsl(139 66% 69% / 0.15);\n  }\n\n  /* Section */\n  .ProseMirror .hljs-section {\n    color: hsl(212 97% 81%);\n    font-weight: bold;\n  }\n\n  /* Emphasis */\n  .ProseMirror .hljs-emphasis {\n    font-style: italic;\n  }\n\n  /* Strong */\n  .ProseMirror .hljs-strong {\n    font-weight: bold;\n  }\n\n  /* Punctuation */\n  .ProseMirror .hljs-punctuation {\n    color: hsl(210 14% 66%);\n  }\n\n  /* Pre code reset */\n  .ProseMirror pre code {\n    background: transparent;\n    padding: 0;\n    font-size: inherit;\n    color: inherit;\n    font-family: inherit;\n  }\n`\n\n// Inject styles once\nlet stylesInjected = false\nexport function injectCodeBlockStyles() {\n  if (stylesInjected || typeof document === \"undefined\") return\n  const styleEl = document.createElement(\"style\")\n  styleEl.id = \"editor-codeblock-styles\"\n  styleEl.textContent = CODEBLOCK_STYLES\n  document.head.appendChild(styleEl)\n  stylesInjected = true\n}\n\n// =============================================================================\n// EditorBubbleMenuCodeBlock\n// =============================================================================\n\nexport interface EditorBubbleMenuCodeBlockProps extends Omit<\n  React.ComponentProps<typeof BubbleMenu>,\n  \"editor\" | \"children\"\n> {\n  children?: React.ReactNode\n}\n\nexport function EditorBubbleMenuCodeBlock(\n  props: EditorBubbleMenuCodeBlockProps\n) {\n  const ctx = React.useContext(EditorContext)\n  const editor = ctx?.editor\n  const [open, setOpen] = React.useState(false)\n  const [copied, setCopied] = React.useState(false)\n\n  // Inject styles on first render\n  React.useEffect(() => {\n    injectCodeBlockStyles()\n  }, [])\n\n  if (!editor) return null\n\n  const currentLanguage =\n    editor.getAttributes(\"codeBlock\").language || \"plaintext\"\n\n  const currentLanguageLabel =\n    CODEBLOCK_LANGUAGES.find((lang) => lang.value === currentLanguage)?.name ||\n    currentLanguage\n\n  const handleSelectLanguage = (value: string) => {\n    editor\n      .chain()\n      .focus()\n      .updateAttributes(\"codeBlock\", { language: value })\n      .run()\n    setOpen(false)\n  }\n\n  const handleCopyCode = async () => {\n    const { state } = editor\n    const { from } = state.selection\n\n    let codeContent = \"\"\n\n    // Try to find the code block and get its content\n    state.doc.nodesBetween(from, from, (node) => {\n      if (node.type.name === \"codeBlock\") {\n        codeContent = node.textContent\n        return false\n      }\n      // Also handle if we're inside the text of a code block\n      if (node.type.name === \"text\") {\n        // Check parent\n        const $pos = state.doc.resolve(from)\n        for (let depth = $pos.depth; depth >= 0; depth--) {\n          const parentNode = $pos.node(depth)\n          if (parentNode.type.name === \"codeBlock\") {\n            codeContent = parentNode.textContent\n            return false\n          }\n        }\n      }\n      return true\n    })\n\n    // Fallback: traverse from current position up to find code block\n    if (!codeContent) {\n      const $pos = state.doc.resolve(from)\n      for (let depth = $pos.depth; depth >= 0; depth--) {\n        const node = $pos.node(depth)\n        if (node.type.name === \"codeBlock\") {\n          codeContent = node.textContent\n          break\n        }\n      }\n    }\n\n    if (codeContent) {\n      await navigator.clipboard.writeText(codeContent)\n      setCopied(true)\n      setTimeout(() => setCopied(false), 2000)\n    }\n  }\n\n  const handleDelete = () => {\n    const { state } = editor\n    const { from } = state.selection\n\n    // Find the code block node position\n    let codeBlockPos: number | null = null\n    let codeBlockNode: typeof state.doc | null = null\n\n    // Traverse up from the current position to find the code block\n    const $pos = state.doc.resolve(from)\n    for (let depth = $pos.depth; depth >= 0; depth--) {\n      const node = $pos.node(depth)\n      if (node.type.name === \"codeBlock\") {\n        codeBlockPos = $pos.before(depth)\n        codeBlockNode = node\n        break\n      }\n    }\n\n    if (codeBlockPos !== null && codeBlockNode) {\n      // Delete the entire code block\n      editor\n        .chain()\n        .focus()\n        .deleteRange({\n          from: codeBlockPos,\n          to: codeBlockPos + codeBlockNode.nodeSize,\n        })\n        .run()\n    }\n  }\n\n  return (\n    <BubbleMenu\n      {...props}\n      editor={editor}\n      tippyOptions={{\n        duration: 100,\n        placement: \"top-end\",\n        offset: [0, 8],\n        getReferenceClientRect: () => {\n          const { view, state } = editor\n          const { from } = state.selection\n\n          // Find the code block node and get its position\n          let codeBlockPos = from\n          state.doc.nodesBetween(from, from, (node, pos) => {\n            if (node.type.name === \"codeBlock\") {\n              codeBlockPos = pos\n              return false\n            }\n          })\n\n          const domNode = view.nodeDOM(codeBlockPos)\n          if (domNode instanceof HTMLElement) {\n            const preElement = domNode.querySelector(\"pre\") || domNode\n            if (preElement instanceof HTMLElement) {\n              return preElement.getBoundingClientRect()\n            }\n          }\n          return view.dom.getBoundingClientRect()\n        },\n      }}\n      shouldShow={({ editor: e }) => e.isActive(\"codeBlock\")}\n      className=\"w-fit\"\n    >\n      <div className=\"bg-popover flex items-center gap-0.5 rounded-md border p-0.5 shadow-md\">\n        {/* Language Selector with Search */}\n        <Popover open={open} onOpenChange={setOpen}>\n          <PopoverTrigger asChild>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-7 gap-1 px-2 text-xs font-normal\"\n              role=\"combobox\"\n              aria-expanded={open}\n            >\n              <Code2 className=\"size-3.5\" />\n              {currentLanguageLabel}\n              <ChevronDown className=\"size-3 opacity-50\" />\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent\n            className=\"w-[200px] p-0\"\n            align=\"start\"\n            sideOffset={8}\n          >\n            <Command>\n              <CommandInput placeholder=\"Search language...\" className=\"h-9\" />\n              <CommandList>\n                <CommandEmpty>No language found.</CommandEmpty>\n                <CommandGroup>\n                  {CODEBLOCK_LANGUAGES.map((lang) => (\n                    <CommandItem\n                      key={lang.value}\n                      value={lang.name}\n                      onSelect={() => handleSelectLanguage(lang.value)}\n                    >\n                      {lang.name}\n                      {currentLanguage === lang.value && (\n                        <Check className=\"ml-auto size-4\" />\n                      )}\n                    </CommandItem>\n                  ))}\n                </CommandGroup>\n              </CommandList>\n            </Command>\n          </PopoverContent>\n        </Popover>\n\n        {/* Divider */}\n        <div className=\"bg-border h-4 w-px\" />\n\n        {/* Copy Button */}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          className=\"h-7 w-7 p-0\"\n          onClick={handleCopyCode}\n          title={copied ? \"Copied!\" : \"Copy code\"}\n        >\n          {copied ? (\n            <Check className=\"size-3.5 text-green-500\" />\n          ) : (\n            <ClipboardCopy className=\"size-3.5\" />\n          )}\n        </Button>\n\n        {/* Divider */}\n        <div className=\"bg-border h-4 w-px\" />\n\n        {/* Delete Button */}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          className=\"text-destructive hover:text-destructive hover:bg-destructive/10 h-7 w-7 p-0\"\n          onClick={handleDelete}\n          title=\"Delete code block\"\n        >\n          <Trash2 className=\"size-3.5\" />\n        </Button>\n      </div>\n    </BubbleMenu>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-color.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport Color from \"@tiptap/extension-color\"\nimport { TextStyle } from \"@tiptap/extension-text-style\"\nimport Highlight from \"@tiptap/extension-highlight\"\nimport type { Editor } from \"@tiptap/react\"\nimport { useEditorState } from \"@tiptap/react\"\nimport { HexColorPicker } from \"react-colorful\"\nimport { Palette, Type } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport {\n  createEditorExtension,\n  EditorBubbleMenuDropdown,\n  EditorBubbleMenuDropdownContent,\n  EditorBubbleMenuDropdownLabel,\n  EditorBubbleMenuDropdownTrigger,\n  useEditor,\n} from \"./editor\"\n\n// =============================================================================\n// EditorColorPicker Context\n// =============================================================================\n\ninterface EditorColorPickerContextValue {\n  currentTextColor: string\n  currentHighlightColor: string\n  setTextColor: (color: string) => void\n  setHighlightColor: (color: string) => void\n}\n\nconst EditorColorPickerContext =\n  React.createContext<EditorColorPickerContextValue | null>(null)\n\nfunction useEditorColorPicker() {\n  const ctx = React.useContext(EditorColorPickerContext)\n  if (!ctx) {\n    throw new Error(\n      \"useEditorColorPicker must be used within EditorColorPicker\"\n    )\n  }\n  return ctx\n}\n\n// =============================================================================\n// EditorColorPicker\n// =============================================================================\n\nexport interface EditorColorPickerProps {\n  children: React.ReactNode\n  defaultOpen?: boolean\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n}\n\nfunction EditorColorPicker({ children, ...props }: EditorColorPickerProps) {\n  const { editor } = useEditor()\n\n  const { currentTextColor, currentHighlightColor } = useEditorState({\n    editor: editor ?? null,\n    selector: ({ editor: e }) => ({\n      currentTextColor:\n        (e?.getAttributes(\"textStyle\").color as string) || \"inherit\",\n      currentHighlightColor:\n        (e?.getAttributes(\"highlight\").color as string) || \"transparent\",\n    }),\n  }) ?? { currentTextColor: \"inherit\", currentHighlightColor: \"transparent\" }\n\n  const setTextColor = React.useCallback(\n    (color: string) => {\n      if (!editor) return\n      if (color === \"inherit\") {\n        editor.chain().focus().unsetColor().run()\n      } else {\n        editor.chain().focus().setColor(color).run()\n      }\n    },\n    [editor]\n  )\n\n  const setHighlightColor = React.useCallback(\n    (color: string) => {\n      if (!editor) return\n      if (color === \"transparent\") {\n        editor.chain().focus().unsetHighlight().run()\n      } else {\n        editor.chain().focus().setHighlight({ color }).run()\n      }\n    },\n    [editor]\n  )\n\n  const contextValue = React.useMemo<EditorColorPickerContextValue>(\n    () => ({\n      currentTextColor,\n      currentHighlightColor,\n      setTextColor,\n      setHighlightColor,\n    }),\n    [currentTextColor, currentHighlightColor, setTextColor, setHighlightColor]\n  )\n\n  if (!editor) return null\n\n  return (\n    <EditorColorPickerContext.Provider value={contextValue}>\n      <EditorBubbleMenuDropdown {...props}>{children}</EditorBubbleMenuDropdown>\n    </EditorColorPickerContext.Provider>\n  )\n}\nEditorColorPicker.displayName = \"EditorColorPicker\"\n\n// =============================================================================\n// EditorColorPickerTrigger\n// =============================================================================\n\nexport interface EditorColorPickerTriggerProps {\n  children: React.ReactNode\n}\n\nfunction EditorColorPickerTrigger({ children }: EditorColorPickerTriggerProps) {\n  return (\n    <EditorBubbleMenuDropdownTrigger>\n      {children}\n    </EditorBubbleMenuDropdownTrigger>\n  )\n}\nEditorColorPickerTrigger.displayName = \"EditorColorPickerTrigger\"\n\n// =============================================================================\n// EditorColorPickerContent\n// =============================================================================\n\nexport interface EditorColorPickerContentProps extends React.ComponentProps<\n  typeof EditorBubbleMenuDropdownContent\n> {}\n\nconst EditorColorPickerContent = React.forwardRef<\n  React.ElementRef<typeof EditorBubbleMenuDropdownContent>,\n  EditorColorPickerContentProps\n>(({ className, children, ...props }, ref) => (\n  <EditorBubbleMenuDropdownContent\n    ref={ref}\n    className={cn(\"w-48\", className)}\n    {...props}\n  >\n    {children}\n  </EditorBubbleMenuDropdownContent>\n))\nEditorColorPickerContent.displayName = \"EditorColorPickerContent\"\n\n// =============================================================================\n// EditorColorPickerLabel\n// =============================================================================\n\nexport interface EditorColorPickerLabelProps extends React.ComponentProps<\n  typeof EditorBubbleMenuDropdownLabel\n> {}\n\nconst EditorColorPickerLabel = React.forwardRef<\n  React.ElementRef<typeof EditorBubbleMenuDropdownLabel>,\n  EditorColorPickerLabelProps\n>((props, ref) => <EditorBubbleMenuDropdownLabel ref={ref} {...props} />)\nEditorColorPickerLabel.displayName = \"EditorColorPickerLabel\"\n\n// =============================================================================\n// EditorColorPickerGrid\n// =============================================================================\n\nexport interface EditorColorPickerGridProps extends React.ComponentProps<\"div\"> {}\n\nconst EditorColorPickerGrid = React.forwardRef<\n  HTMLDivElement,\n  EditorColorPickerGridProps\n>(({ className, children, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\"grid grid-cols-5 gap-1 px-1 py-1\", className)}\n      {...props}\n    >\n      {children}\n    </div>\n  )\n})\nEditorColorPickerGrid.displayName = \"EditorColorPickerGrid\"\n\n// =============================================================================\n// EditorColorPickerItem\n// =============================================================================\n\nexport interface EditorColorPickerItemProps extends Omit<\n  React.ComponentProps<\"button\">,\n  \"color\"\n> {\n  color: string\n  variant: \"text\" | \"highlight\"\n}\n\nconst EditorColorPickerItem = React.forwardRef<\n  HTMLButtonElement,\n  EditorColorPickerItemProps\n>(({ color, variant, className, onClick, ...props }, ref) => {\n  const {\n    currentTextColor,\n    currentHighlightColor,\n    setTextColor,\n    setHighlightColor,\n  } = useEditorColorPicker()\n\n  const isActive =\n    variant === \"text\"\n      ? currentTextColor === color\n      : currentHighlightColor === color\n\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    if (variant === \"text\") {\n      setTextColor(color)\n    } else {\n      setHighlightColor(color)\n    }\n    onClick?.(e)\n  }\n\n  const isDefault = color === \"inherit\" || color === \"transparent\"\n\n  return (\n    <button\n      ref={ref}\n      type=\"button\"\n      className={cn(\n        \"flex size-7 items-center justify-center rounded-full transition-all\",\n        \"hover:ring-ring hover:ring-2 hover:ring-offset-1\",\n        \"focus-visible:ring-ring focus-visible:ring-2 focus-visible:ring-offset-1 focus-visible:outline-none\",\n        isActive && \"ring-primary ring-2 ring-offset-1\",\n        className\n      )}\n      style={\n        variant === \"highlight\"\n          ? { backgroundColor: isDefault ? \"#e3e2e0\" : color }\n          : undefined\n      }\n      onClick={handleClick}\n      {...props}\n    >\n      {variant === \"text\" && (\n        <span\n          className={cn(\n            \"text-sm font-semibold\",\n            isDefault && \"text-foreground\"\n          )}\n          style={!isDefault ? { color } : undefined}\n        >\n          A\n        </span>\n      )}\n      {variant === \"highlight\" && isDefault && (\n        <span className=\"text-muted-foreground relative size-full\">\n          <span className=\"bg-destructive absolute top-1/2 left-1/2 h-px w-5/6 -translate-x-1/2 -translate-y-1/2 rotate-45\" />\n        </span>\n      )}\n    </button>\n  )\n})\nEditorColorPickerItem.displayName = \"EditorColorPickerItem\"\n\n// =============================================================================\n// EditorColorPickerIndicator\n// =============================================================================\n\nexport interface EditorColorPickerIndicatorProps extends React.ComponentProps<\"div\"> {}\n\nconst EditorColorPickerIndicator = React.forwardRef<\n  HTMLDivElement,\n  EditorColorPickerIndicatorProps\n>(({ className, ...props }, ref) => {\n  const { currentTextColor, currentHighlightColor } = useEditorColorPicker()\n\n  const backgroundColor =\n    currentHighlightColor !== \"transparent\"\n      ? currentHighlightColor\n      : currentTextColor !== \"inherit\"\n        ? currentTextColor\n        : \"currentColor\"\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"absolute inset-x-1.5 bottom-1 h-0.5 rounded-full\",\n        className\n      )}\n      style={{ backgroundColor }}\n      {...props}\n    />\n  )\n})\nEditorColorPickerIndicator.displayName = \"EditorColorPickerIndicator\"\n\n// =============================================================================\n// EditorColorPickerCustom\n// =============================================================================\n\nexport interface EditorColorPickerCustomProps extends Omit<\n  React.ComponentProps<\"button\">,\n  \"onChange\" | \"color\"\n> {\n  variant: \"text\" | \"highlight\"\n}\n\nconst EditorColorPickerCustom = React.forwardRef<\n  HTMLButtonElement,\n  EditorColorPickerCustomProps\n>(({ variant, className, ...props }, ref) => {\n  const [open, setOpen] = React.useState(false)\n  const [isDragging, setIsDragging] = React.useState(false)\n  const {\n    currentTextColor,\n    currentHighlightColor,\n    setTextColor,\n    setHighlightColor,\n  } = useEditorColorPicker()\n\n  const currentColor =\n    variant === \"text\" ? currentTextColor : currentHighlightColor\n\n  const displayColor =\n    currentColor === \"inherit\" || currentColor === \"transparent\"\n      ? \"#000000\"\n      : currentColor\n\n  const handleChange = (color: string) => {\n    if (variant === \"text\") {\n      setTextColor(color)\n    } else {\n      setHighlightColor(color)\n    }\n  }\n\n  const handlePointerDown = () => {\n    setIsDragging(true)\n  }\n\n  const handlePointerUp = () => {\n    setIsDragging(false)\n  }\n\n  React.useEffect(() => {\n    if (open) {\n      window.addEventListener(\"pointerup\", handlePointerUp)\n      return () => window.removeEventListener(\"pointerup\", handlePointerUp)\n    }\n  }, [open])\n\n  const handleInteractOutside = (e: Event) => {\n    if (isDragging) {\n      e.preventDefault()\n    }\n  }\n\n  const isDefault = currentColor === \"inherit\" || currentColor === \"transparent\"\n  const hasCustomColor = !isDefault\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <button\n          ref={ref}\n          type=\"button\"\n          className={cn(\n            \"flex size-7 items-center justify-center rounded-full transition-all\",\n            \"hover:ring-ring hover:ring-2 hover:ring-offset-1\",\n            \"focus-visible:ring-ring focus-visible:ring-2 focus-visible:ring-offset-1 focus-visible:outline-none\",\n            hasCustomColor\n              ? \"ring-primary ring-2 ring-offset-1\"\n              : \"bg-muted border-border border border-dashed\",\n            className\n          )}\n          style={\n            variant === \"highlight\" && hasCustomColor\n              ? { backgroundColor: currentColor }\n              : undefined\n          }\n          title=\"Custom color\"\n          {...props}\n        >\n          {variant === \"text\" ? (\n            <span\n              className={cn(\n                \"text-sm font-semibold\",\n                !hasCustomColor && \"text-muted-foreground\"\n              )}\n              style={hasCustomColor ? { color: currentColor } : undefined}\n            >\n              A\n            </span>\n          ) : (\n            !hasCustomColor && (\n              <Palette className=\"text-muted-foreground size-3.5\" />\n            )\n          )}\n        </button>\n      </PopoverTrigger>\n      <PopoverContent\n        className=\"z-[9999] w-auto p-3\"\n        align=\"start\"\n        sideOffset={8}\n        onOpenAutoFocus={(e) => e.preventDefault()}\n        onPointerDownOutside={handleInteractOutside}\n        onInteractOutside={handleInteractOutside}\n      >\n        <div onPointerDown={handlePointerDown}>\n          <HexColorPicker\n            color={displayColor}\n            onChange={handleChange}\n            style={{ width: \"180px\", height: \"140px\" }}\n          />\n        </div>\n      </PopoverContent>\n    </Popover>\n  )\n})\nEditorColorPickerCustom.displayName = \"EditorColorPickerCustom\"\n\n// =============================================================================\n// EditorColorExtension\n// =============================================================================\n\nexport const EditorColorExtension = createEditorExtension({\n  extension: [\n    TextStyle,\n    Color,\n    Highlight.configure({\n      multicolor: true,\n      HTMLAttributes: {\n        class: \"px-0.5 rounded\",\n      },\n    }),\n  ],\n  commands: [\n    {\n      key: \"setTextColor\",\n      icon: Type,\n      label: \"Text Color\",\n      description: \"Change text color\",\n      execute: (editor: Editor, options) =>\n        editor\n          .chain()\n          .focus()\n          .setColor(options?.color as string)\n          .run(),\n      canExecute: () => true,\n      isActive: (editor: Editor) =>\n        editor.getAttributes(\"textStyle\").color !== undefined,\n    },\n    {\n      key: \"unsetTextColor\",\n      icon: Type,\n      label: \"Remove Text Color\",\n      description: \"Remove text color\",\n      execute: (editor: Editor) => editor.chain().focus().unsetColor().run(),\n      canExecute: (editor: Editor) =>\n        editor.getAttributes(\"textStyle\").color !== undefined,\n      isActive: () => false,\n    },\n    {\n      key: \"setHighlightColor\",\n      icon: Type,\n      label: \"Highlight\",\n      description: \"Highlight selected text\",\n      execute: (editor: Editor, options) =>\n        editor\n          .chain()\n          .focus()\n          .setHighlight({ color: options?.color as string })\n          .run(),\n      canExecute: () => true,\n      isActive: (editor: Editor) => editor.isActive(\"highlight\"),\n    },\n    {\n      key: \"unsetHighlightColor\",\n      icon: Type,\n      label: \"Remove Highlight\",\n      description: \"Remove highlight\",\n      execute: (editor: Editor) =>\n        editor.chain().focus().unsetHighlight().run(),\n      canExecute: (editor: Editor) => editor.isActive(\"highlight\"),\n      isActive: () => false,\n    },\n  ],\n})\n\n// =============================================================================\n// Exports\n// =============================================================================\n\nexport {\n  EditorColorPicker,\n  EditorColorPickerTrigger,\n  EditorColorPickerContent,\n  EditorColorPickerLabel,\n  EditorColorPickerGrid,\n  EditorColorPickerItem,\n  EditorColorPickerIndicator,\n  EditorColorPickerCustom,\n  useEditorColorPicker,\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-essential.tsx",
      "content": "\"use client\"\n\nimport type { Editor } from \"@tiptap/react\"\nimport { TextAlign } from \"@tiptap/extension-text-align\"\nimport TiptapTypography from \"@tiptap/extension-typography\"\nimport TiptapUnderline from \"@tiptap/extension-underline\"\nimport StarterKit from \"@tiptap/starter-kit\"\nimport {\n  AlignCenter,\n  AlignJustify,\n  AlignLeft,\n  AlignRight,\n  Bold,\n  Code,\n  Heading1,\n  Heading2,\n  Heading3,\n  Heading4,\n  Heading5,\n  Heading6,\n  Italic,\n  List,\n  ListOrdered,\n  Minus,\n  Redo,\n  Strikethrough,\n  TextQuote,\n  Type,\n  Underline,\n  Undo,\n} from \"lucide-react\"\nimport { createEditorExtension, type EditorActionConfig } from \"./editor\"\n\nconst essentialCommands: EditorActionConfig<Editor>[] = [\n  // History\n  {\n    key: \"undo\",\n    icon: Undo,\n    label: \"Undo\",\n    description: \"Undo the last action\",\n    execute: (editor) => editor.chain().focus().undo().run(),\n    canExecute: (editor) => editor.can().chain().focus().undo().run(),\n  },\n  {\n    key: \"redo\",\n    icon: Redo,\n    label: \"Redo\",\n    description: \"Redo the last action\",\n    execute: (editor) => editor.chain().focus().redo().run(),\n    canExecute: (editor) => editor.can().chain().focus().redo().run(),\n  },\n  // Text formatting\n  {\n    key: \"bold\",\n    icon: Bold,\n    label: \"Bold\",\n    description: \"Make text bold\",\n    execute: (editor) => editor.chain().focus().toggleBold().run(),\n    canExecute: (editor) => editor.can().chain().focus().toggleBold().run(),\n    isActive: (editor) => editor.isActive(\"bold\"),\n  },\n  {\n    key: \"italic\",\n    icon: Italic,\n    label: \"Italic\",\n    description: \"Italicize text\",\n    execute: (editor) => editor.chain().focus().toggleItalic().run(),\n    canExecute: (editor) => editor.can().chain().focus().toggleItalic().run(),\n    isActive: (editor) => editor.isActive(\"italic\"),\n  },\n  {\n    key: \"underline\",\n    icon: Underline,\n    label: \"Underline\",\n    description: \"Underline text\",\n    execute: (editor) => editor.chain().focus().toggleUnderline().run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().toggleUnderline().run(),\n    isActive: (editor) => editor.isActive(\"underline\"),\n  },\n  {\n    key: \"strike\",\n    icon: Strikethrough,\n    label: \"Strikethrough\",\n    description: \"Strike through text\",\n    execute: (editor) => editor.chain().focus().toggleStrike().run(),\n    canExecute: (editor) => editor.can().chain().focus().toggleStrike().run(),\n    isActive: (editor) => editor.isActive(\"strike\"),\n  },\n  {\n    key: \"code\",\n    icon: Code,\n    label: \"Code\",\n    description: \"Format text as code\",\n    execute: (editor) => editor.chain().focus().toggleCode().run(),\n    canExecute: (editor) => editor.can().chain().focus().toggleCode().run(),\n    isActive: (editor) => editor.isActive(\"code\"),\n  },\n  // Block types\n  {\n    key: \"paragraph\",\n    icon: Type,\n    label: \"Text\",\n    description: \"Start writing with plain text\",\n    execute: (editor) => editor.chain().focus().setParagraph().run(),\n    canExecute: (editor) => editor.can().chain().focus().setParagraph().run(),\n    isActive: (editor) => editor.isActive(\"paragraph\"),\n  },\n  {\n    key: \"heading1\",\n    icon: Heading1,\n    label: \"Heading 1\",\n    description: \"Use this for main titles\",\n    execute: (editor) => editor.chain().focus().setHeading({ level: 1 }).run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setHeading({ level: 1 }).run(),\n    isActive: (editor) => editor.isActive(\"heading\", { level: 1 }),\n  },\n  {\n    key: \"heading2\",\n    icon: Heading2,\n    label: \"Heading 2\",\n    description: \"Ideal for subsections\",\n    execute: (editor) => editor.chain().focus().setHeading({ level: 2 }).run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setHeading({ level: 2 }).run(),\n    isActive: (editor) => editor.isActive(\"heading\", { level: 2 }),\n  },\n  {\n    key: \"heading3\",\n    icon: Heading3,\n    label: \"Heading 3\",\n    description: \"Use for smaller subsections\",\n    execute: (editor) => editor.chain().focus().setHeading({ level: 3 }).run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setHeading({ level: 3 }).run(),\n    isActive: (editor) => editor.isActive(\"heading\", { level: 3 }),\n  },\n  {\n    key: \"heading4\",\n    icon: Heading4,\n    label: \"Heading 4\",\n    description: \"Suitable for detailed sections\",\n    execute: (editor) => editor.chain().focus().setHeading({ level: 4 }).run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setHeading({ level: 4 }).run(),\n    isActive: (editor) => editor.isActive(\"heading\", { level: 4 }),\n  },\n  {\n    key: \"heading5\",\n    icon: Heading5,\n    label: \"Heading 5\",\n    description: \"For minor details\",\n    execute: (editor) => editor.chain().focus().setHeading({ level: 5 }).run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setHeading({ level: 5 }).run(),\n    isActive: (editor) => editor.isActive(\"heading\", { level: 5 }),\n  },\n  {\n    key: \"heading6\",\n    icon: Heading6,\n    label: \"Heading 6\",\n    description: \"Use for the smallest details\",\n    execute: (editor) => editor.chain().focus().setHeading({ level: 6 }).run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setHeading({ level: 6 }).run(),\n    isActive: (editor) => editor.isActive(\"heading\", { level: 6 }),\n  },\n  {\n    key: \"blockquote\",\n    icon: TextQuote,\n    label: \"Quote\",\n    description: \"Capture a quote\",\n    execute: (editor) => editor.chain().focus().toggleBlockquote().run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().toggleBlockquote().run(),\n    isActive: (editor) => editor.isActive(\"blockquote\"),\n  },\n  {\n    key: \"divider\",\n    icon: Minus,\n    label: \"Divider\",\n    description: \"Visually divide blocks\",\n    execute: (editor) => editor.chain().focus().setHorizontalRule().run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setHorizontalRule().run(),\n  },\n  // Lists\n  {\n    key: \"bulletList\",\n    icon: List,\n    label: \"Bullet List\",\n    description: \"Create a bullet list\",\n    execute: (editor) => editor.chain().focus().toggleBulletList().run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().toggleBulletList().run(),\n    isActive: (editor) => editor.isActive(\"bulletList\"),\n  },\n  {\n    key: \"orderedList\",\n    icon: ListOrdered,\n    label: \"Ordered List\",\n    description: \"Create an ordered list\",\n    execute: (editor) => editor.chain().focus().toggleOrderedList().run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().toggleOrderedList().run(),\n    isActive: (editor) => editor.isActive(\"orderedList\"),\n  },\n  // Text alignment\n  {\n    key: \"left\",\n    icon: AlignLeft,\n    label: \"Left\",\n    description: \"Align text to the left\",\n    execute: (editor) => editor.chain().focus().setTextAlign(\"left\").run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setTextAlign(\"left\").run(),\n    isActive: (editor) => editor.isActive({ textAlign: \"left\" }),\n  },\n  {\n    key: \"center\",\n    icon: AlignCenter,\n    label: \"Center\",\n    description: \"Align text to the center\",\n    execute: (editor) => editor.chain().focus().setTextAlign(\"center\").run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setTextAlign(\"center\").run(),\n    isActive: (editor) => editor.isActive({ textAlign: \"center\" }),\n  },\n  {\n    key: \"right\",\n    icon: AlignRight,\n    label: \"Right\",\n    description: \"Align text to the right\",\n    execute: (editor) => editor.chain().focus().setTextAlign(\"right\").run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setTextAlign(\"right\").run(),\n    isActive: (editor) => editor.isActive({ textAlign: \"right\" }),\n  },\n  {\n    key: \"justify\",\n    icon: AlignJustify,\n    label: \"Justify\",\n    description: \"Align text to justify\",\n    execute: (editor) => editor.chain().focus().setTextAlign(\"justify\").run(),\n    canExecute: (editor) =>\n      editor.can().chain().focus().setTextAlign(\"justify\").run(),\n    isActive: (editor) => editor.isActive({ textAlign: \"justify\" }),\n  },\n]\n\nexport const EditorEssentialExtension = createEditorExtension({\n  extension: [\n    StarterKit.configure({\n      codeBlock: false, // Use CodeBlock extension separately\n    }),\n    TiptapUnderline.configure({\n      HTMLAttributes: {\n        class: \"underline underline-offset-4\",\n      },\n    }),\n    TextAlign.configure({\n      types: [\n        \"heading\",\n        \"paragraph\",\n        \"blockquote\",\n        \"bulletList\",\n        \"orderedList\",\n      ],\n    }),\n    TiptapTypography.configure({}),\n  ],\n  commands: essentialCommands,\n})\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-highlight.tsx",
      "content": "\"use client\"\n\nimport type { Editor } from \"@tiptap/react\"\nimport Highlight from \"@tiptap/extension-highlight\"\nimport { Highlighter } from \"lucide-react\"\nimport { createEditorExtension } from \"./editor\"\n\n// =============================================================================\n// EditorHighlightExtension\n// =============================================================================\n\nexport const EditorHighlightExtension = createEditorExtension({\n  extension: Highlight.configure({\n    multicolor: false,\n    HTMLAttributes: {\n      class: \"bg-yellow-200 dark:bg-yellow-500 px-0.5 rounded\",\n    },\n  }),\n  commands: [\n    {\n      key: \"highlight\",\n      icon: Highlighter,\n      label: \"Highlight\",\n      description: \"Highlight selected text\",\n      execute: (editor: Editor) =>\n        editor.chain().focus().toggleHighlight().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().toggleHighlight().run(),\n      isActive: (editor: Editor) => editor.isActive(\"highlight\"),\n    },\n  ],\n})\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-image.tsx",
      "content": "\"use client\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  DropdownMenu,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { Input } from \"@/components/ui/input\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\"\nimport { cn } from \"@/lib/utils\"\nimport { DropdownMenuContent as DropdownMenuContentPrimitive } from \"@radix-ui/react-dropdown-menu\"\nimport { Node, mergeAttributes } from \"@tiptap/core\"\nimport {\n  BubbleMenu,\n  NodeViewWrapper,\n  ReactNodeViewRenderer,\n} from \"@tiptap/react\"\nimport {\n  AlertCircle,\n  AlignCenter,\n  AlignLeft,\n  AlignRight,\n  Check,\n  ChevronDown,\n  ImageUp,\n  Link2,\n  Loader2,\n  Lock,\n  LockOpen,\n  MessageSquare,\n  Trash2,\n  Upload,\n  X,\n} from \"lucide-react\"\nimport * as React from \"react\"\nimport { EditorContext, createEditorExtension } from \"./editor\"\n\n// =============================================================================\n// Types & Configuration\n// =============================================================================\n\nexport type EditorImageUploadStrategy = \"base64\" | \"server\" | \"url\"\nexport type EditorImageAlignment = \"left\" | \"center\" | \"right\"\nexport type EditorImageObjectFit =\n  | \"contain\"\n  | \"cover\"\n  | \"fill\"\n  | \"none\"\n  | \"scale-down\"\n\nexport interface EditorImageConfig {\n  uploadStrategy?: EditorImageUploadStrategy\n  onUpload?: (file: File) => Promise<string>\n  maxFileSize?: number\n  acceptedTypes?: string[]\n  onError?: (error: Error) => void\n}\n\nconst DEFAULT_CONFIG: Required<\n  Omit<EditorImageConfig, \"onUpload\" | \"onError\">\n> = {\n  uploadStrategy: \"base64\",\n  maxFileSize: 5 * 1024 * 1024, // 5MB\n  acceptedTypes: [\"image/jpeg\", \"image/png\", \"image/gif\", \"image/webp\"],\n}\n\n// =============================================================================\n// Context\n// =============================================================================\n\ninterface EditorImageContextType extends EditorImageConfig {\n  isUploading: boolean\n  setIsUploading: (value: boolean) => void\n  error: string | null\n  setError: (value: string | null) => void\n}\n\nconst EditorImageContext = React.createContext<EditorImageContextType | null>(\n  null\n)\n\n// =============================================================================\n// Utility Functions\n// =============================================================================\n\nfunction formatFileSize(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`\n  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`\n}\n\nasync function convertToBase64(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onload = () => resolve(reader.result as string)\n    reader.onerror = reject\n    reader.readAsDataURL(file)\n  })\n}\n\nfunction validateFile(\n  file: File,\n  config: Pick<EditorImageConfig, \"maxFileSize\" | \"acceptedTypes\">\n): string | null {\n  const maxSize = config.maxFileSize ?? DEFAULT_CONFIG.maxFileSize\n  const acceptedTypes = config.acceptedTypes ?? DEFAULT_CONFIG.acceptedTypes\n\n  if (!acceptedTypes.includes(file.type)) {\n    return `Invalid file type. Accepted: ${acceptedTypes.map((t) => t.split(\"/\")[1]).join(\", \")}`\n  }\n\n  if (file.size > maxSize) {\n    return `File too large. Maximum size: ${formatFileSize(maxSize)}`\n  }\n\n  return null\n}\n\n// =============================================================================\n// EditorImagePlaceholder - Upload UI shown when src is empty\n// =============================================================================\n\ninterface EditorImagePlaceholderProps {\n  onImageReady: (src: string, alt?: string) => void\n  config: EditorImageConfig\n}\n\nexport function EditorImagePlaceholder({\n  onImageReady,\n  config,\n}: EditorImagePlaceholderProps) {\n  const [isUploading, setIsUploading] = React.useState(false)\n  const [error, setError] = React.useState<string | null>(null)\n  const [activeTab, setActiveTab] = React.useState<string>(\"upload\")\n\n  const contextValue: EditorImageContextType = {\n    ...config,\n    isUploading,\n    setIsUploading,\n    error,\n    setError,\n  }\n\n  const handleUpload = React.useCallback(\n    async (file: File) => {\n      setError(null)\n\n      const validationError = validateFile(file, config)\n      if (validationError) {\n        setError(validationError)\n        return\n      }\n\n      setIsUploading(true)\n\n      try {\n        let src: string\n\n        const strategy = config.uploadStrategy ?? DEFAULT_CONFIG.uploadStrategy\n\n        if (strategy === \"server\" && config.onUpload) {\n          src = await config.onUpload(file)\n        } else {\n          src = await convertToBase64(file)\n        }\n\n        onImageReady(src, file.name)\n      } catch (err) {\n        const message = err instanceof Error ? err.message : \"Upload failed\"\n        setError(message)\n        config.onError?.(err instanceof Error ? err : new Error(message))\n      } finally {\n        setIsUploading(false)\n      }\n    },\n    [config, onImageReady]\n  )\n\n  const handleUrlSubmit = React.useCallback(\n    (url: string) => {\n      if (!url.trim()) {\n        setError(\"Please enter a valid URL\")\n        return\n      }\n\n      try {\n        new URL(url)\n        onImageReady(url)\n      } catch {\n        setError(\"Please enter a valid URL\")\n      }\n    },\n    [onImageReady]\n  )\n\n  return (\n    <EditorImageContext.Provider value={contextValue}>\n      <div className=\"border-border bg-muted/30 my-4 rounded-lg border\">\n        <Tabs value={activeTab} onValueChange={setActiveTab}>\n          <TabsList className=\"mt-2 ml-2\">\n            <TabsTrigger value=\"upload\">\n              <Upload className=\"mr-2 size-4\" />\n              Upload\n            </TabsTrigger>\n            <TabsTrigger value=\"embed\">\n              <Link2 className=\"mr-2 size-4\" />\n              Embed link\n            </TabsTrigger>\n          </TabsList>\n\n          <div className=\"p-4\">\n            {error && (\n              <div className=\"bg-destructive/10 text-destructive mb-4 flex items-center gap-2 rounded-md p-3 text-sm\">\n                <AlertCircle className=\"size-4 shrink-0\" />\n                <span>{error}</span>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  className=\"ml-auto h-6 w-6 p-0\"\n                  onClick={() => setError(null)}\n                >\n                  <X className=\"size-3\" />\n                </Button>\n              </div>\n            )}\n\n            <TabsContent value=\"upload\" className=\"mt-0\">\n              <EditorImageUploadZone\n                onUpload={handleUpload}\n                disabled={isUploading}\n              />\n              <p className=\"text-muted-foreground mt-3 text-center text-xs\">\n                Maximum file size:{\" \"}\n                {formatFileSize(\n                  config.maxFileSize ?? DEFAULT_CONFIG.maxFileSize\n                )}\n              </p>\n            </TabsContent>\n\n            <TabsContent value=\"embed\" className=\"mt-0\">\n              <EditorImageUrlInput\n                onSubmit={handleUrlSubmit}\n                disabled={isUploading}\n              />\n            </TabsContent>\n          </div>\n        </Tabs>\n      </div>\n    </EditorImageContext.Provider>\n  )\n}\n\n// =============================================================================\n// EditorImageUploadZone - Drag & drop file upload\n// =============================================================================\n\ninterface EditorImageUploadZoneProps {\n  onUpload: (file: File) => void\n  disabled?: boolean\n}\n\nexport function EditorImageUploadZone({\n  onUpload,\n  disabled,\n}: EditorImageUploadZoneProps) {\n  const [isDragOver, setIsDragOver] = React.useState(false)\n  const inputRef = React.useRef<HTMLInputElement>(null)\n  const ctx = React.useContext(EditorImageContext)\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    if (!disabled) setIsDragOver(true)\n  }\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    setIsDragOver(false)\n  }\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    setIsDragOver(false)\n\n    if (disabled) return\n\n    const file = e.dataTransfer.files[0]\n    if (file) onUpload(file)\n  }\n\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0]\n    if (file) onUpload(file)\n    if (inputRef.current) inputRef.current.value = \"\"\n  }\n\n  return (\n    <div\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n      className={cn(\n        \"flex flex-col items-center justify-center rounded-lg border-2 border-dashed p-8 transition-colors\",\n        isDragOver\n          ? \"border-primary bg-primary/5\"\n          : \"border-muted-foreground/25 hover:border-muted-foreground/50\",\n        disabled && \"pointer-events-none opacity-50\"\n      )}\n    >\n      <input\n        ref={inputRef}\n        type=\"file\"\n        accept=\"image/*\"\n        onChange={handleFileSelect}\n        className=\"hidden\"\n        disabled={disabled}\n      />\n\n      {ctx?.isUploading ? (\n        <>\n          <Loader2 className=\"text-muted-foreground size-8 animate-spin\" />\n          <p className=\"text-muted-foreground mt-2 text-sm\">Uploading...</p>\n        </>\n      ) : (\n        <>\n          <ImageUp className=\"text-muted-foreground size-8\" />\n          <Button\n            variant=\"outline\"\n            className=\"mt-4\"\n            onClick={() => inputRef.current?.click()}\n            disabled={disabled}\n          >\n            Upload file\n          </Button>\n          <p className=\"text-muted-foreground mt-2 text-sm\">\n            or drag and drop an image here\n          </p>\n        </>\n      )}\n    </div>\n  )\n}\n\n// =============================================================================\n// EditorImageUrlInput - External URL input\n// =============================================================================\n\ninterface EditorImageUrlInputProps {\n  onSubmit: (url: string) => void\n  disabled?: boolean\n}\n\nexport function EditorImageUrlInput({\n  onSubmit,\n  disabled,\n}: EditorImageUrlInputProps) {\n  const [url, setUrl] = React.useState(\"\")\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault()\n    onSubmit(url)\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault()\n      onSubmit(url)\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit} className=\"flex gap-2\">\n      <Input\n        type=\"url\"\n        placeholder=\"Paste image URL...\"\n        value={url}\n        onChange={(e) => setUrl(e.target.value)}\n        onKeyDown={handleKeyDown}\n        disabled={disabled}\n        className=\"flex-1\"\n      />\n      <Button type=\"submit\" disabled={disabled || !url.trim()}>\n        Embed\n      </Button>\n    </form>\n  )\n}\n\n// =============================================================================\n// Resize Handle Component\n// =============================================================================\n\ntype ResizeDirection = \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\"\n\ninterface ResizeHandleProps {\n  direction: ResizeDirection\n  onResizeStart: (e: React.MouseEvent, direction: ResizeDirection) => void\n}\n\nfunction ResizeHandle({ direction, onResizeStart }: ResizeHandleProps) {\n  const positionClasses: Record<ResizeDirection, string> = {\n    \"top-left\": \"-left-1.5 -top-1.5 cursor-nwse-resize\",\n    \"top-right\": \"-right-1.5 -top-1.5 cursor-nesw-resize\",\n    \"bottom-left\": \"-bottom-1.5 -left-1.5 cursor-nesw-resize\",\n    \"bottom-right\": \"-bottom-1.5 -right-1.5 cursor-nwse-resize\",\n  }\n\n  return (\n    <div\n      className={cn(\n        \"border-primary bg-background absolute size-3 border-2 transition-transform hover:scale-125\",\n        positionClasses[direction]\n      )}\n      onMouseDown={(e) => onResizeStart(e, direction)}\n    />\n  )\n}\n\n// =============================================================================\n// EditorImageBlock - Rendered image with styling\n// =============================================================================\n\ninterface EditorImageBlockProps extends React.ComponentProps<\"img\"> {\n  selected?: boolean\n  imageWidth?: number | string | null\n  imageHeight?: number | string | null\n  objectFit?: EditorImageObjectFit | null\n}\n\nexport const EditorImageBlock = React.forwardRef<\n  HTMLImageElement,\n  EditorImageBlockProps\n>(\n  (\n    {\n      className,\n      selected,\n      imageWidth,\n      imageHeight,\n      objectFit,\n      style,\n      ...props\n    },\n    ref\n  ) => {\n    return (\n      <img\n        ref={ref}\n        {...props}\n        className={cn(\n          \"max-w-full\",\n          selected && \"ring-primary ring-1 ring-offset-1\",\n          className\n        )}\n        style={{\n          margin: 0,\n          ...style,\n          width: imageWidth\n            ? typeof imageWidth === \"string\" && imageWidth.includes(\"%\")\n              ? imageWidth\n              : `${imageWidth}px`\n            : undefined,\n          height: imageHeight\n            ? typeof imageHeight === \"string\" && imageHeight.includes(\"%\")\n              ? imageHeight\n              : `${imageHeight}px`\n            : undefined,\n          objectFit: objectFit ?? undefined,\n        }}\n      />\n    )\n  }\n)\nEditorImageBlock.displayName = \"EditorImageBlock\"\n\n// =============================================================================\n// ImageNodeView - Main NodeView component\n// =============================================================================\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction ImageNodeView(props: any) {\n  const { node, updateAttributes, selected, extension, editor, getPos } = props\n\n  const nodeAttrs = node.attrs as {\n    src: string | null\n    alt: string | null\n    title: string | null\n    width: number | string | null\n    height: number | string | null\n    alignment: EditorImageAlignment\n    caption: string | null\n    objectFit: EditorImageObjectFit\n    lockAspectRatio: boolean\n  }\n\n  const hasSrc = !!nodeAttrs.src\n  const imageRef = React.useRef<HTMLImageElement>(null)\n  const containerRef = React.useRef<HTMLDivElement>(null)\n\n  const [isResizing, setIsResizing] = React.useState(false)\n  const [resizeDirection, setResizeDirection] =\n    React.useState<ResizeDirection | null>(null)\n  const [initialSize, setInitialSize] = React.useState({ width: 0, height: 0 })\n  const [initialMousePos, setInitialMousePos] = React.useState({ x: 0, y: 0 })\n  const [currentSize, setCurrentSize] = React.useState<{\n    width: number\n    height: number\n  } | null>(null)\n\n  const handleImageReady = React.useCallback(\n    (src: string, alt?: string) => {\n      updateAttributes({ src, alt: alt ?? nodeAttrs.alt })\n\n      requestAnimationFrame(() => {\n        const pos = getPos?.()\n        if (typeof pos === \"number\" && editor) {\n          editor.commands.setNodeSelection(pos)\n          editor.commands.focus()\n        }\n      })\n    },\n    [updateAttributes, nodeAttrs.alt, getPos, editor]\n  )\n\n  const handleResizeStart = React.useCallback(\n    (e: React.MouseEvent, direction: ResizeDirection) => {\n      e.preventDefault()\n      e.stopPropagation()\n\n      if (!imageRef.current) return\n\n      const rect = imageRef.current.getBoundingClientRect()\n      setIsResizing(true)\n      setResizeDirection(direction)\n      setInitialSize({\n        width: rect.width,\n        height: rect.height,\n      })\n      setInitialMousePos({ x: e.clientX, y: e.clientY })\n      setCurrentSize({ width: rect.width, height: rect.height })\n    },\n    []\n  )\n\n  React.useEffect(() => {\n    if (!isResizing) return\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!resizeDirection) return\n\n      const deltaX = e.clientX - initialMousePos.x\n      const deltaY = e.clientY - initialMousePos.y\n\n      let newWidth = initialSize.width\n      let newHeight = initialSize.height\n\n      if (resizeDirection.includes(\"right\")) newWidth += deltaX\n      if (resizeDirection.includes(\"left\")) newWidth -= deltaX\n      if (resizeDirection.includes(\"bottom\")) newHeight += deltaY\n      if (resizeDirection.includes(\"top\")) newHeight -= deltaY\n\n      const shouldLockRatio = e.shiftKey || nodeAttrs.lockAspectRatio\n      if (shouldLockRatio && initialSize.width > 0 && initialSize.height > 0) {\n        const aspectRatio = initialSize.width / initialSize.height\n        const containerMaxWidth =\n          containerRef.current?.parentElement?.clientWidth ?? Infinity\n\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n          newWidth = Math.min(newWidth, containerMaxWidth)\n          newHeight = newWidth / aspectRatio\n        } else {\n          newWidth = newHeight * aspectRatio\n          if (newWidth > containerMaxWidth) {\n            newWidth = containerMaxWidth\n            newHeight = newWidth / aspectRatio\n          }\n        }\n      }\n\n      newWidth = Math.max(50, newWidth)\n      newHeight = Math.max(50, newHeight)\n\n      setCurrentSize({\n        width: Math.round(newWidth),\n        height: Math.round(newHeight),\n      })\n    }\n\n    const handleMouseUp = () => {\n      if (currentSize) {\n        updateAttributes({\n          width: currentSize.width,\n          height: currentSize.height,\n        })\n      }\n      setIsResizing(false)\n      setResizeDirection(null)\n      setCurrentSize(null)\n    }\n\n    document.addEventListener(\"mousemove\", handleMouseMove)\n    document.addEventListener(\"mouseup\", handleMouseUp)\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove)\n      document.removeEventListener(\"mouseup\", handleMouseUp)\n    }\n  }, [\n    isResizing,\n    resizeDirection,\n    initialMousePos,\n    initialSize,\n    currentSize,\n    updateAttributes,\n    nodeAttrs.lockAspectRatio,\n  ])\n\n  const displayWidth = currentSize?.width ?? nodeAttrs.width\n  const displayHeight = currentSize?.height ?? nodeAttrs.height\n\n  const alignmentClasses: Record<EditorImageAlignment, string> = {\n    left: \"items-start\",\n    center: \"items-center\",\n    right: \"items-end\",\n  }\n\n  return (\n    <NodeViewWrapper\n      data-type=\"image\"\n      data-src={nodeAttrs.src ?? undefined}\n      data-alt={nodeAttrs.alt ?? undefined}\n      data-title={nodeAttrs.title ?? undefined}\n      data-alignment={nodeAttrs.alignment}\n    >\n      {hasSrc ? (\n        <figure\n          className={cn(\n            \"my-4 flex w-full flex-col\",\n            alignmentClasses[nodeAttrs.alignment]\n          )}\n        >\n          <div\n            ref={containerRef}\n            className={cn(\n              \"group relative inline-block\",\n              isResizing && \"select-none\"\n            )}\n          >\n            <EditorImageBlock\n              ref={imageRef}\n              src={nodeAttrs.src!}\n              alt={nodeAttrs.alt ?? undefined}\n              title={nodeAttrs.title ?? undefined}\n              selected={selected}\n              imageWidth={displayWidth}\n              imageHeight={displayHeight}\n              objectFit={nodeAttrs.objectFit}\n              draggable={!isResizing}\n            />\n            {selected && (\n              <>\n                <ResizeHandle\n                  direction=\"top-left\"\n                  onResizeStart={handleResizeStart}\n                />\n                <ResizeHandle\n                  direction=\"top-right\"\n                  onResizeStart={handleResizeStart}\n                />\n                <ResizeHandle\n                  direction=\"bottom-left\"\n                  onResizeStart={handleResizeStart}\n                />\n                <ResizeHandle\n                  direction=\"bottom-right\"\n                  onResizeStart={handleResizeStart}\n                />\n              </>\n            )}\n            {isResizing && currentSize && (\n              <div className=\"absolute bottom-2 left-2 rounded bg-black/70 px-2 py-1 text-xs text-white\">\n                {currentSize.width}  {currentSize.height}\n              </div>\n            )}\n          </div>\n          {nodeAttrs.caption && (\n            <figcaption className=\"text-muted-foreground mt-2 text-center text-sm\">\n              {nodeAttrs.caption}\n            </figcaption>\n          )}\n        </figure>\n      ) : (\n        <EditorImagePlaceholder\n          onImageReady={handleImageReady}\n          config={extension.options}\n        />\n      )}\n    </NodeViewWrapper>\n  )\n}\n\n// =============================================================================\n// EditorImageExtension\n// =============================================================================\n\nexport interface EditorImageOptions extends EditorImageConfig {\n  inline: boolean\n  HTMLAttributes: Record<string, unknown>\n}\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    editorImage: {\n      setImage: (options: {\n        src?: string | null\n        alt?: string\n        title?: string\n      }) => ReturnType\n    }\n  }\n}\n\nconst EditorImageNode = Node.create<EditorImageOptions>({\n  name: \"image\",\n\n  addOptions() {\n    return {\n      inline: false,\n      uploadStrategy: \"base64\",\n      maxFileSize: 5 * 1024 * 1024,\n      acceptedTypes: [\"image/jpeg\", \"image/png\", \"image/gif\", \"image/webp\"],\n      HTMLAttributes: {\n        class: \"rounded-lg border object-contain\",\n      },\n    }\n  },\n\n  inline() {\n    return this.options.inline\n  },\n\n  group() {\n    return this.options.inline ? \"inline\" : \"block\"\n  },\n\n  draggable: true,\n  atom: false,\n\n  addAttributes() {\n    return {\n      src: {\n        default: null,\n        parseHTML: (el) => (el as HTMLImageElement).getAttribute(\"src\"),\n        renderHTML: (attrs) => (attrs.src ? { src: attrs.src } : {}),\n      },\n      alt: {\n        default: null,\n        parseHTML: (el) => (el as HTMLImageElement).getAttribute(\"alt\"),\n        renderHTML: (attrs) => (attrs.alt ? { alt: attrs.alt } : {}),\n      },\n      title: {\n        default: null,\n        parseHTML: (el) => (el as HTMLImageElement).getAttribute(\"title\"),\n        renderHTML: (attrs) => (attrs.title ? { title: attrs.title } : {}),\n      },\n      width: {\n        default: null,\n        parseHTML: (el) => {\n          const width = (el as HTMLImageElement).getAttribute(\"width\")\n          if (!width) return null\n          return width.includes(\"%\") ? width : parseInt(width, 10)\n        },\n        renderHTML: (attrs) => (attrs.width ? { width: attrs.width } : {}),\n      },\n      height: {\n        default: null,\n        parseHTML: (el) => {\n          const height = (el as HTMLImageElement).getAttribute(\"height\")\n          if (!height) return null\n          return height.includes(\"%\") ? height : parseInt(height, 10)\n        },\n        renderHTML: (attrs) => (attrs.height ? { height: attrs.height } : {}),\n      },\n      alignment: {\n        default: \"left\" as EditorImageAlignment,\n        parseHTML: (el) =>\n          (el as HTMLElement).getAttribute(\"data-alignment\") ?? \"left\",\n        renderHTML: (attrs) => ({ \"data-alignment\": attrs.alignment }),\n      },\n      caption: {\n        default: null,\n        parseHTML: (el) => (el as HTMLElement).getAttribute(\"data-caption\"),\n        renderHTML: (attrs) =>\n          attrs.caption ? { \"data-caption\": attrs.caption } : {},\n      },\n      objectFit: {\n        default: \"contain\" as EditorImageObjectFit,\n        parseHTML: (el) =>\n          (el as HTMLElement).getAttribute(\"data-object-fit\") ?? \"contain\",\n        renderHTML: (attrs) => ({ \"data-object-fit\": attrs.objectFit }),\n      },\n      lockAspectRatio: {\n        default: true,\n        parseHTML: (el) =>\n          (el as HTMLElement).getAttribute(\"data-lock-aspect-ratio\") !==\n          \"false\",\n        renderHTML: (attrs) => ({\n          \"data-lock-aspect-ratio\": String(attrs.lockAspectRatio),\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [{ tag: \"img[src]\" }, { tag: \"img\" }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"img\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addNodeView() {\n    return ReactNodeViewRenderer(ImageNodeView)\n  },\n\n  addCommands() {\n    return {\n      setImage:\n        (options) =>\n        ({ commands }) => {\n          return commands.insertContent({\n            type: this.name,\n            attrs: options,\n          })\n        },\n    }\n  },\n})\n\nexport const EditorImageExtension = createEditorExtension<EditorImageOptions>({\n  extension: EditorImageNode,\n  bubbleMenu: EditorBubbleMenuImage,\n  commands: [\n    {\n      key: \"image\",\n      icon: ImageUp,\n      label: \"Image\",\n      description: \"Upload or embed an image\",\n      execute: (editor, options) =>\n        editor\n          .chain()\n          .focus()\n          .setImage({\n            src: options?.src as string,\n            alt: options?.alt as string,\n            title: options?.title as string,\n          })\n          .run(),\n      canExecute: () => true,\n    },\n  ],\n  onConfigure: (options, current) => ({\n    ...current,\n    extension: EditorImageNode.configure(options),\n  }),\n})\n\n// =============================================================================\n// EditorBubbleMenuImage\n// =============================================================================\n\nconst OBJECT_FIT_OPTIONS: { value: EditorImageObjectFit; label: string }[] = [\n  { value: \"contain\", label: \"Contain\" },\n  { value: \"cover\", label: \"Cover\" },\n  { value: \"fill\", label: \"Fill\" },\n  { value: \"none\", label: \"None\" },\n  { value: \"scale-down\", label: \"Scale Down\" },\n]\n\nexport function EditorBubbleMenuImage() {\n  const ctx = React.useContext(EditorContext)\n  const editor = ctx?.editor\n  const [captionOpen, setCaptionOpen] = React.useState(false)\n  const [captionValue, setCaptionValue] = React.useState(\"\")\n  const widthInputRef = React.useRef<HTMLInputElement>(null)\n  const heightInputRef = React.useRef<HTMLInputElement>(null)\n  const [forceUpdate, setForceUpdate] = React.useState(0)\n\n  const isImageActive = editor?.isActive(\"image\") ?? false\n\n  // Subscribe to editor transaction updates to sync dimensions\n  React.useEffect(() => {\n    if (!editor) return\n\n    const handleUpdate = () => {\n      if (editor.isActive(\"image\")) {\n        setForceUpdate((prev) => prev + 1)\n      }\n    }\n\n    editor.on(\"transaction\", handleUpdate)\n    editor.on(\"selectionUpdate\", handleUpdate)\n\n    return () => {\n      editor.off(\"transaction\", handleUpdate)\n      editor.off(\"selectionUpdate\", handleUpdate)\n    }\n  }, [editor])\n\n  const getDefaultDimensions = React.useCallback(() => {\n    if (!editor || !isImageActive) return { width: \"\", height: \"\" }\n\n    const attrs = editor.getAttributes(\"image\")\n\n    if (attrs.width && attrs.height) {\n      return {\n        width: attrs.width.toString(),\n        height: attrs.height.toString(),\n      }\n    }\n\n    const { node } = editor.state.selection as {\n      node?: { type?: { name?: string }; attrs?: { src?: string } }\n    }\n    if (node?.type?.name === \"image\" && node.attrs?.src) {\n      const imageElement = editor.view.dom.querySelector(\n        `img[src=\"${node.attrs.src}\"]`\n      ) as HTMLImageElement | null\n\n      if (imageElement?.complete && imageElement.naturalWidth > 0) {\n        const rect = imageElement.getBoundingClientRect()\n        return {\n          width: Math.round(rect.width).toString(),\n          height: Math.round(rect.height).toString(),\n        }\n      }\n    }\n\n    return { width: \"\", height: \"\" }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor, isImageActive, forceUpdate])\n\n  const defaultDimensions = getDefaultDimensions()\n\n  if (!editor) return null\n\n  const getImageAttrs = () => {\n    if (!isImageActive) return null\n    return editor.getAttributes(\"image\") as {\n      src: string | null\n      alt: string | null\n      width: number | string | null\n      height: number | string | null\n      alignment: EditorImageAlignment\n      caption: string | null\n      objectFit: EditorImageObjectFit\n      lockAspectRatio: boolean\n    }\n  }\n\n  const attrs = getImageAttrs()\n  const isConstrained = attrs?.lockAspectRatio ?? true\n\n  const handleToggleLockAspectRatio = () => {\n    editor\n      .chain()\n      .focus()\n      .updateAttributes(\"image\", { lockAspectRatio: !isConstrained })\n      .run()\n  }\n\n  const parseValue = (\n    value: string\n  ): { numericValue: number; isPercentage: boolean } | null => {\n    const trimmed = value.trim()\n    if (!trimmed) return null\n\n    const isPercentage = trimmed.endsWith(\"%\")\n    const numStr = isPercentage ? trimmed.slice(0, -1) : trimmed\n    const numValue = parseFloat(numStr)\n\n    if (isNaN(numValue) || numValue <= 0) return null\n    if (isPercentage && numValue > 100) return null\n\n    return { numericValue: numValue, isPercentage }\n  }\n\n  const formatValue = (\n    numericValue: number,\n    isPercentage: boolean\n  ): string | number => {\n    return isPercentage ? `${numericValue}%` : Math.round(numericValue)\n  }\n\n  const applyWidth = (value: string) => {\n    const parsed = parseValue(value)\n    if (!parsed) return\n\n    const { numericValue, isPercentage } = parsed\n    const formattedValue = formatValue(numericValue, isPercentage)\n\n    if (\n      isConstrained &&\n      defaultDimensions.width &&\n      defaultDimensions.height &&\n      !isPercentage\n    ) {\n      const currentWidth = parseFloat(defaultDimensions.width)\n      const currentHeight = parseFloat(defaultDimensions.height)\n      if (currentWidth > 0 && currentHeight > 0) {\n        const aspectRatio = currentHeight / currentWidth\n        const newHeight = Math.round(numericValue * aspectRatio)\n        editor\n          .chain()\n          .focus()\n          .updateAttributes(\"image\", {\n            width: formattedValue,\n            height: newHeight,\n          })\n          .run()\n        return\n      }\n    }\n\n    editor\n      .chain()\n      .focus()\n      .updateAttributes(\"image\", { width: formattedValue })\n      .run()\n  }\n\n  const applyHeight = (value: string) => {\n    const parsed = parseValue(value)\n    if (!parsed) return\n\n    const { numericValue, isPercentage } = parsed\n    const formattedValue = formatValue(numericValue, isPercentage)\n\n    if (\n      isConstrained &&\n      defaultDimensions.width &&\n      defaultDimensions.height &&\n      !isPercentage\n    ) {\n      const currentWidth = parseFloat(defaultDimensions.width)\n      const currentHeight = parseFloat(defaultDimensions.height)\n      if (currentWidth > 0 && currentHeight > 0) {\n        const aspectRatio = currentWidth / currentHeight\n        const newWidth = Math.round(numericValue * aspectRatio)\n        editor\n          .chain()\n          .focus()\n          .updateAttributes(\"image\", {\n            width: newWidth,\n            height: formattedValue,\n          })\n          .run()\n        return\n      }\n    }\n\n    editor\n      .chain()\n      .focus()\n      .updateAttributes(\"image\", { height: formattedValue })\n      .run()\n  }\n\n  const handleWidthBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    applyWidth(e.target.value)\n  }\n\n  const handleHeightBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    applyHeight(e.target.value)\n  }\n\n  const handleWidthKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault()\n      applyWidth(e.currentTarget.value)\n    }\n  }\n\n  const handleHeightKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault()\n      applyHeight(e.currentTarget.value)\n    }\n  }\n\n  const handleAlignmentChange = (alignment: EditorImageAlignment) => {\n    editor.chain().focus().updateAttributes(\"image\", { alignment }).run()\n  }\n\n  const handleObjectFitChange = (objectFit: EditorImageObjectFit) => {\n    editor.chain().focus().updateAttributes(\"image\", { objectFit }).run()\n  }\n\n  const handleCaptionSave = () => {\n    editor\n      .chain()\n      .focus()\n      .updateAttributes(\"image\", { caption: captionValue || null })\n      .run()\n    setCaptionOpen(false)\n  }\n\n  const handleCaptionOpen = () => {\n    const attrs = getImageAttrs()\n    setCaptionValue(attrs?.caption ?? \"\")\n    setCaptionOpen(true)\n  }\n\n  const handleDelete = () => {\n    editor.chain().focus().deleteSelection().run()\n  }\n\n  return (\n    <BubbleMenu\n      editor={editor}\n      tippyOptions={{\n        duration: 100,\n        placement: \"bottom\",\n        offset: [0, 8],\n        getReferenceClientRect: () => {\n          const { state, view } = editor\n          const { selection } = state\n\n          const { node } = selection as {\n            node?: { type?: { name?: string }; attrs?: { src?: string } }\n          }\n          if (node?.type?.name === \"image\" && node.attrs?.src) {\n            const imageElement = view.dom.querySelector(\n              `[data-type=\"image\"][data-src=\"${node.attrs.src}\"] img`\n            ) as HTMLImageElement | null\n\n            if (imageElement) {\n              return imageElement.getBoundingClientRect()\n            }\n          }\n\n          const selectedImageWrapper = view.dom\n            .querySelector('[data-type=\"image\"] .ring-primary')\n            ?.closest('[data-type=\"image\"]') as HTMLElement | null\n\n          if (selectedImageWrapper) {\n            const img = selectedImageWrapper.querySelector(\"img\")\n            if (img) {\n              return img.getBoundingClientRect()\n            }\n          }\n\n          const { from, to } = selection\n          const start = view.coordsAtPos(from)\n          const end = view.coordsAtPos(to)\n\n          return new DOMRect(\n            start.left,\n            start.top,\n            end.right - start.left,\n            end.bottom - start.top\n          )\n        },\n      }}\n      shouldShow={({ editor: e }) => e.isActive(\"image\")}\n      className=\"w-fit\"\n    >\n      <div className=\"bg-popover flex items-center gap-1 rounded-md border p-1 shadow-md\">\n        {/* Size Controls */}\n        <div className=\"flex items-center gap-1\">\n          <Input\n            ref={widthInputRef}\n            key={`width-${defaultDimensions.width}-${isConstrained}`}\n            type=\"text\"\n            placeholder=\"W\"\n            defaultValue={defaultDimensions.width}\n            onBlur={handleWidthBlur}\n            onKeyDown={handleWidthKeyDown}\n            className=\"h-7 w-16 text-xs\"\n          />\n          <Button\n            variant={isConstrained ? \"secondary\" : \"ghost\"}\n            size=\"sm\"\n            className=\"h-7 w-7 p-0\"\n            onClick={handleToggleLockAspectRatio}\n            title={isConstrained ? \"Unlock aspect ratio\" : \"Lock aspect ratio\"}\n          >\n            {isConstrained ? (\n              <Lock className=\"size-2\" />\n            ) : (\n              <LockOpen className=\"size-2\" />\n            )}\n          </Button>\n          <Input\n            ref={heightInputRef}\n            key={`height-${defaultDimensions.height}-${isConstrained}`}\n            type=\"text\"\n            placeholder=\"H\"\n            defaultValue={defaultDimensions.height}\n            onBlur={handleHeightBlur}\n            onKeyDown={handleHeightKeyDown}\n            className=\"h-7 w-16 text-xs\"\n          />\n        </div>\n\n        <div className=\"bg-border mx-1 h-5 w-px\" />\n\n        {/* Alignment Controls */}\n        <div className=\"flex items-center gap-0.5\">\n          <Button\n            variant={attrs?.alignment === \"left\" ? \"secondary\" : \"ghost\"}\n            size=\"sm\"\n            className=\"h-7 w-7 p-0\"\n            onClick={() => handleAlignmentChange(\"left\")}\n            title=\"Align left\"\n          >\n            <AlignLeft className=\"size-3.5\" />\n          </Button>\n          <Button\n            variant={attrs?.alignment === \"center\" ? \"secondary\" : \"ghost\"}\n            size=\"sm\"\n            className=\"h-7 w-7 p-0\"\n            onClick={() => handleAlignmentChange(\"center\")}\n            title=\"Align center\"\n          >\n            <AlignCenter className=\"size-3.5\" />\n          </Button>\n          <Button\n            variant={attrs?.alignment === \"right\" ? \"secondary\" : \"ghost\"}\n            size=\"sm\"\n            className=\"h-7 w-7 p-0\"\n            onClick={() => handleAlignmentChange(\"right\")}\n            title=\"Align right\"\n          >\n            <AlignRight className=\"size-3.5\" />\n          </Button>\n        </div>\n\n        <div className=\"bg-border mx-1 h-5 w-px\" />\n\n        {/* Object Fit Selector */}\n        <DropdownMenu>\n          <DropdownMenuTrigger asChild>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-7 gap-1 px-2 text-xs\"\n            >\n              {OBJECT_FIT_OPTIONS.find((o) => o.value === attrs?.objectFit)\n                ?.label || \"Contain\"}\n              <ChevronDown className=\"size-3 opacity-50\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContentPrimitive\n            className={cn(\n              \"bg-popover text-popover-foreground z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md\",\n              \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95\"\n            )}\n            align=\"start\"\n            sideOffset={8}\n          >\n            {OBJECT_FIT_OPTIONS.map((option) => (\n              <DropdownMenuItem\n                key={option.value}\n                onClick={() => handleObjectFitChange(option.value)}\n              >\n                {option.label}\n                {attrs?.objectFit === option.value && (\n                  <Check className=\"ml-auto size-4\" />\n                )}\n              </DropdownMenuItem>\n            ))}\n          </DropdownMenuContentPrimitive>\n        </DropdownMenu>\n\n        <div className=\"bg-border mx-1 h-5 w-px\" />\n\n        {/* Caption Popover */}\n        <Popover open={captionOpen} onOpenChange={setCaptionOpen}>\n          <PopoverTrigger asChild>\n            <Button\n              variant={attrs?.caption ? \"secondary\" : \"ghost\"}\n              size=\"sm\"\n              className=\"h-7 gap-1 px-2 text-xs\"\n              onClick={handleCaptionOpen}\n              title=\"Add caption\"\n            >\n              <MessageSquare className=\"size-3.5\" />\n              Caption\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-64 p-3\" align=\"start\" sideOffset={8}>\n            <div className=\"space-y-2\">\n              <p className=\"text-sm font-medium\">Image Caption</p>\n              <Input\n                placeholder=\"Enter caption...\"\n                value={captionValue}\n                onChange={(e) => setCaptionValue(e.target.value)}\n                onKeyDown={(e) => {\n                  if (e.key === \"Enter\") {\n                    e.preventDefault()\n                    handleCaptionSave()\n                  }\n                }}\n              />\n              <div className=\"flex justify-end gap-2\">\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setCaptionValue(\"\")\n                    editor\n                      .chain()\n                      .focus()\n                      .updateAttributes(\"image\", { caption: null })\n                      .run()\n                    setCaptionOpen(false)\n                  }}\n                >\n                  Clear\n                </Button>\n                <Button size=\"sm\" onClick={handleCaptionSave}>\n                  Save\n                </Button>\n              </div>\n            </div>\n          </PopoverContent>\n        </Popover>\n\n        <div className=\"bg-border mx-1 h-5 w-px\" />\n\n        {/* Delete Button */}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          className=\"text-destructive hover:text-destructive hover:bg-destructive/10 h-7 w-7 p-0\"\n          onClick={handleDelete}\n          title=\"Delete image\"\n        >\n          <Trash2 className=\"size-3.5\" />\n        </Button>\n      </div>\n    </BubbleMenu>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-link.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport Link from \"@tiptap/extension-link\"\nimport { BubbleMenu, type Editor } from \"@tiptap/react\"\nimport { EditorContext, createEditorExtension } from \"./editor\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Check, ExternalLink, Link2, Link2Off } from \"lucide-react\"\n\n// =============================================================================\n// EditorLinkExtension\n// =============================================================================\n\nexport const EditorLinkExtension = Link.configure({\n  openOnClick: false,\n  HTMLAttributes: {\n    class:\n      \"text-primary underline underline-offset-4 hover:text-primary/80 cursor-pointer\",\n  },\n})\n\n// =============================================================================\n// EditorBubbleMenuLink\n// =============================================================================\n\nexport interface EditorBubbleMenuLinkProps extends Omit<\n  React.ComponentProps<typeof BubbleMenu>,\n  \"editor\" | \"children\"\n> {}\n\nexport const EditorBubbleMenuLink = React.forwardRef<\n  HTMLDivElement,\n  EditorBubbleMenuLinkProps\n>((props, ref) => {\n  const ctx = React.useContext(EditorContext)\n  const editor = ctx?.editor\n  const [isEditing, setIsEditing] = React.useState(false)\n  const [linkUrl, setLinkUrl] = React.useState(\"\")\n\n  if (!editor) return null\n\n  const currentLink = editor.getAttributes(\"link\").href || \"\"\n\n  const handleEditLink = () => {\n    setLinkUrl(currentLink)\n    setIsEditing(true)\n  }\n\n  const handleSaveLink = () => {\n    if (linkUrl) {\n      editor\n        .chain()\n        .focus()\n        .extendMarkRange(\"link\")\n        .setLink({ href: linkUrl })\n        .run()\n    }\n    setIsEditing(false)\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault()\n      handleSaveLink()\n    }\n    if (e.key === \"Escape\") {\n      setIsEditing(false)\n    }\n  }\n\n  const handleOpenLink = () => {\n    if (currentLink) {\n      window.open(currentLink, \"_blank\", \"noopener,noreferrer\")\n    }\n  }\n\n  return (\n    <BubbleMenu\n      {...props}\n      editor={editor}\n      tippyOptions={{\n        duration: 100,\n        placement: \"bottom\",\n      }}\n      shouldShow={({ editor: e, from, to }) => {\n        if (from !== to) return false\n        return e.isActive(\"link\")\n      }}\n      className=\"w-fit\"\n    >\n      <div\n        ref={ref}\n        className=\"bg-popover flex items-center gap-0.5 rounded-md border p-0.5 shadow-md\"\n      >\n        {isEditing ? (\n          <div className=\"flex items-center gap-1 px-1\">\n            <Input\n              type=\"url\"\n              placeholder=\"https://...\"\n              value={linkUrl}\n              onChange={(e) => setLinkUrl(e.target.value)}\n              onKeyDown={handleKeyDown}\n              className=\"h-7 w-48 text-xs\"\n              autoFocus\n            />\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-7 w-7 p-0\"\n              onClick={handleSaveLink}\n            >\n              <Check className=\"size-3.5\" />\n            </Button>\n          </div>\n        ) : (\n          <>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-7 max-w-[200px] gap-1 truncate px-2 text-xs font-normal\"\n              onClick={handleEditLink}\n              title=\"Edit link\"\n            >\n              <Link2 className=\"size-3.5 shrink-0\" />\n              <span className=\"truncate\">{currentLink}</span>\n            </Button>\n\n            <div className=\"bg-border h-4 w-px\" />\n\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-7 w-7 p-0\"\n              onClick={handleOpenLink}\n              title=\"Open link\"\n            >\n              <ExternalLink className=\"size-3.5\" />\n            </Button>\n\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"text-destructive hover:text-destructive h-7 w-7 p-0\"\n              onClick={() => editor.chain().focus().unsetLink().run()}\n              title=\"Remove link\"\n            >\n              <Link2Off className=\"size-3.5\" />\n            </Button>\n          </>\n        )}\n      </div>\n    </BubbleMenu>\n  )\n})\nEditorBubbleMenuLink.displayName = \"EditorBubbleMenuLink\"\n\n// =============================================================================\n// EditorLinkExtensions (Bundled Extension + BubbleMenu)\n// =============================================================================\n\nexport const EditorLinkExtensions = createEditorExtension({\n  extension: EditorLinkExtension,\n  bubbleMenu: EditorBubbleMenuLink,\n  commands: [\n    {\n      key: \"setLink\",\n      icon: Link2,\n      label: \"Add Link\",\n      description: \"Insert a hyperlink\",\n      execute: (editor: Editor, options) =>\n        editor\n          .chain()\n          .focus()\n          .setLink({ href: options?.href as string })\n          .run(),\n      canExecute: () => true,\n      isActive: (editor: Editor) => editor.isActive(\"link\"),\n    },\n    {\n      key: \"unsetLink\",\n      icon: Link2Off,\n      label: \"Remove Link\",\n      description: \"Remove the hyperlink\",\n      execute: (editor: Editor) => editor.chain().focus().unsetLink().run(),\n      canExecute: (editor: Editor) => editor.isActive(\"link\"),\n      isActive: (editor: Editor) => editor.isActive(\"link\"),\n    },\n  ],\n})\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-placeholder.tsx",
      "content": "\"use client\"\n\nimport Placeholder from \"@tiptap/extension-placeholder\"\n\n// =============================================================================\n// Placeholder Styles (Tailwind CSS classes for EditorContent)\n// =============================================================================\n\n/**\n * Apply these classes to EditorContent component to enable placeholder styling.\n * These use Tailwind's arbitrary selector syntax for ProseMirror elements.\n *\n * Usage:\n * ```tsx\n * <EditorContent className={cn(\"prose\", EDITOR_PLACEHOLDER_CLASSES)} />\n * ```\n */\nexport const EDITOR_PLACEHOLDER_CLASSES = [\n  // Empty paragraph placeholder\n  \"[&_.ProseMirror_p.is-empty::before]:text-muted-foreground\",\n  \"[&_.ProseMirror_p.is-empty::before]:content-[attr(data-placeholder)]\",\n  \"[&_.ProseMirror_p.is-empty::before]:float-left\",\n  \"[&_.ProseMirror_p.is-empty::before]:h-0\",\n  \"[&_.ProseMirror_p.is-empty::before]:pointer-events-none\",\n  // Empty heading placeholders (h1-h6)\n  \"[&_.ProseMirror_h1.is-empty::before]:text-muted-foreground\",\n  \"[&_.ProseMirror_h1.is-empty::before]:content-[attr(data-placeholder)]\",\n  \"[&_.ProseMirror_h1.is-empty::before]:float-left\",\n  \"[&_.ProseMirror_h1.is-empty::before]:h-0\",\n  \"[&_.ProseMirror_h1.is-empty::before]:pointer-events-none\",\n  \"[&_.ProseMirror_h2.is-empty::before]:text-muted-foreground\",\n  \"[&_.ProseMirror_h2.is-empty::before]:content-[attr(data-placeholder)]\",\n  \"[&_.ProseMirror_h2.is-empty::before]:float-left\",\n  \"[&_.ProseMirror_h2.is-empty::before]:h-0\",\n  \"[&_.ProseMirror_h2.is-empty::before]:pointer-events-none\",\n  \"[&_.ProseMirror_h3.is-empty::before]:text-muted-foreground\",\n  \"[&_.ProseMirror_h3.is-empty::before]:content-[attr(data-placeholder)]\",\n  \"[&_.ProseMirror_h3.is-empty::before]:float-left\",\n  \"[&_.ProseMirror_h3.is-empty::before]:h-0\",\n  \"[&_.ProseMirror_h3.is-empty::before]:pointer-events-none\",\n  \"[&_.ProseMirror_h4.is-empty::before]:text-muted-foreground\",\n  \"[&_.ProseMirror_h4.is-empty::before]:content-[attr(data-placeholder)]\",\n  \"[&_.ProseMirror_h4.is-empty::before]:float-left\",\n  \"[&_.ProseMirror_h4.is-empty::before]:h-0\",\n  \"[&_.ProseMirror_h4.is-empty::before]:pointer-events-none\",\n  \"[&_.ProseMirror_h5.is-empty::before]:text-muted-foreground\",\n  \"[&_.ProseMirror_h5.is-empty::before]:content-[attr(data-placeholder)]\",\n  \"[&_.ProseMirror_h5.is-empty::before]:float-left\",\n  \"[&_.ProseMirror_h5.is-empty::before]:h-0\",\n  \"[&_.ProseMirror_h5.is-empty::before]:pointer-events-none\",\n  \"[&_.ProseMirror_h6.is-empty::before]:text-muted-foreground\",\n  \"[&_.ProseMirror_h6.is-empty::before]:content-[attr(data-placeholder)]\",\n  \"[&_.ProseMirror_h6.is-empty::before]:float-left\",\n  \"[&_.ProseMirror_h6.is-empty::before]:h-0\",\n  \"[&_.ProseMirror_h6.is-empty::before]:pointer-events-none\",\n].join(\" \")\n\n// =============================================================================\n// EditorPlaceholderExtension\n// =============================================================================\n\nexport interface EditorPlaceholderOptions {\n  placeholder?:\n    | string\n    | ((props: {\n        node: { type: { name: string }; attrs: { level?: number } }\n      }) => string)\n  emptyEditorClass?: string\n  emptyNodeClass?: string\n}\n\n/**\n * Creates a configured Placeholder extension.\n *\n * @example\n * ```tsx\n * // Default configuration\n * EditorPlaceholderExtension\n *\n * // Custom placeholder\n * createEditorPlaceholderExtension({\n *   placeholder: \"Write something amazing...\"\n * })\n * ```\n */\nexport function createEditorPlaceholderExtension(\n  options: EditorPlaceholderOptions = {}\n) {\n  return Placeholder.configure({\n    placeholder:\n      options.placeholder ??\n      (({ node }) => {\n        if (node.type.name === \"heading\") {\n          return `Heading ${node.attrs.level}`\n        }\n        return \"Type '/' for commands...\"\n      }),\n    emptyEditorClass: options.emptyEditorClass ?? \"is-editor-empty\",\n    emptyNodeClass: options.emptyNodeClass ?? \"is-empty\",\n  })\n}\n\n// Default export with standard configuration\nexport const EditorPlaceholderExtension = createEditorPlaceholderExtension()\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-slash-menu.tsx",
      "content": "\"use client\"\n\nimport { ScrollArea } from \"@/components/ui/scroll-area\"\nimport { cn } from \"@/lib/utils\"\nimport { Extension } from \"@tiptap/core\"\nimport { ReactRenderer } from \"@tiptap/react\"\nimport Suggestion, { type SuggestionOptions } from \"@tiptap/suggestion\"\nimport {\n  CheckSquare,\n  Code2,\n  Heading1,\n  Heading2,\n  Heading3,\n  ImageUp,\n  List,\n  ListOrdered,\n  Minus,\n  Table,\n  TextQuote,\n  Type,\n} from \"lucide-react\"\nimport * as React from \"react\"\nimport tippy, { type Instance, type Props } from \"tippy.js\"\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface SlashMenuItem {\n  title: string\n  description: string\n  icon: React.ElementType\n  searchTerms: string[]\n  command: (\n    editor: ReturnType<typeof import(\"@tiptap/react\").useEditor>\n  ) => void\n}\n\ninterface SlashMenuListProps {\n  items: SlashMenuItem[]\n  command: (item: SlashMenuItem) => void\n}\n\ninterface SlashMenuListRef {\n  onKeyDown: (event: KeyboardEvent) => boolean\n}\n\n// =============================================================================\n// Default Slash Menu Items\n// =============================================================================\n\nexport const defaultSlashMenuItems: SlashMenuItem[] = [\n  {\n    title: \"Text\",\n    description: \"Start writing with plain text\",\n    icon: Type,\n    searchTerms: [\"text\", \"paragraph\", \"plain\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().setParagraph().run()\n    },\n  },\n  {\n    title: \"Heading 1\",\n    description: \"Large heading\",\n    icon: Heading1,\n    searchTerms: [\"heading\", \"h1\", \"title\", \"large\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().setHeading({ level: 1 }).run()\n    },\n  },\n  {\n    title: \"Heading 2\",\n    description: \"Medium heading\",\n    icon: Heading2,\n    searchTerms: [\"heading\", \"h2\", \"subtitle\", \"medium\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().setHeading({ level: 2 }).run()\n    },\n  },\n  {\n    title: \"Heading 3\",\n    description: \"Small heading\",\n    icon: Heading3,\n    searchTerms: [\"heading\", \"h3\", \"small\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().setHeading({ level: 3 }).run()\n    },\n  },\n  {\n    title: \"Bullet List\",\n    description: \"Create a bullet list\",\n    icon: List,\n    searchTerms: [\"bullet\", \"list\", \"unordered\", \"ul\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().toggleBulletList().run()\n    },\n  },\n  {\n    title: \"Numbered List\",\n    description: \"Create a numbered list\",\n    icon: ListOrdered,\n    searchTerms: [\"numbered\", \"list\", \"ordered\", \"ol\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().toggleOrderedList().run()\n    },\n  },\n  {\n    title: \"Task List\",\n    description: \"Create a task list with checkboxes\",\n    icon: CheckSquare,\n    searchTerms: [\"task\", \"todo\", \"checkbox\", \"checklist\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().toggleTaskList().run()\n    },\n  },\n  {\n    title: \"Quote\",\n    description: \"Capture a quote\",\n    icon: TextQuote,\n    searchTerms: [\"quote\", \"blockquote\", \"cite\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().setBlockquote().run()\n    },\n  },\n  {\n    title: \"Divider\",\n    description: \"Visually divide blocks\",\n    icon: Minus,\n    searchTerms: [\"divider\", \"hr\", \"horizontal\", \"rule\", \"line\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().setHorizontalRule().run()\n    },\n  },\n  {\n    title: \"Code Block\",\n    description: \"Add a code block with syntax highlighting\",\n    icon: Code2,\n    searchTerms: [\"code\", \"codeblock\", \"pre\", \"syntax\"],\n    command: (editor) => {\n      if (editor) editor.chain().focus().toggleCodeBlock().run()\n    },\n  },\n  {\n    title: \"Image\",\n    description: \"Upload or embed an image\",\n    icon: ImageUp,\n    searchTerms: [\"image\", \"img\", \"picture\", \"photo\", \"upload\"],\n    command: (editor) => {\n      if (editor) {\n        editor.chain().focus().setImage({ src: null }).run()\n      }\n    },\n  },\n  {\n    title: \"Table\",\n    description: \"Insert a table\",\n    icon: Table,\n    searchTerms: [\"table\", \"grid\", \"spreadsheet\"],\n    command: (editor) => {\n      if (editor) {\n        editor\n          .chain()\n          .focus()\n          .insertTable({ rows: 3, cols: 3, withHeaderRow: true })\n          .run()\n      }\n    },\n  },\n]\n\n// =============================================================================\n// SlashMenuList Component\n// =============================================================================\n\nconst EditorSlashMenuList = React.forwardRef<\n  SlashMenuListRef,\n  SlashMenuListProps\n>(({ items, command }, ref) => {\n  const [selectedIndex, setSelectedIndex] = React.useState(0)\n  const itemRefs = React.useRef<(HTMLButtonElement | null)[]>([])\n  const isKeyboardNavigating = React.useRef(false)\n\n  React.useEffect(() => {\n    setSelectedIndex(0)\n  }, [items])\n\n  React.useEffect(() => {\n    const selectedItem = itemRefs.current[selectedIndex]\n    if (selectedItem) {\n      selectedItem.scrollIntoView({ block: \"nearest\" })\n    }\n  }, [selectedIndex])\n\n  const handleMouseEnter = (index: number) => {\n    // Ignore mouse enter events during keyboard navigation\n    // to prevent scrolling from triggering selection changes\n    if (isKeyboardNavigating.current) return\n    setSelectedIndex(index)\n  }\n\n  const handleMouseMove = () => {\n    // Re-enable mouse selection after user moves the mouse\n    isKeyboardNavigating.current = false\n  }\n\n  React.useImperativeHandle(ref, () => ({\n    onKeyDown: (event: KeyboardEvent) => {\n      if (event.key === \"ArrowUp\") {\n        isKeyboardNavigating.current = true\n        setSelectedIndex((prev) => (prev <= 0 ? items.length - 1 : prev - 1))\n        return true\n      }\n\n      if (event.key === \"ArrowDown\") {\n        isKeyboardNavigating.current = true\n        setSelectedIndex((prev) => (prev >= items.length - 1 ? 0 : prev + 1))\n        return true\n      }\n\n      if (event.key === \"Enter\") {\n        const item = items[selectedIndex]\n        if (item) {\n          command(item)\n        }\n        return true\n      }\n\n      return false\n    },\n  }))\n\n  if (items.length === 0) {\n    return (\n      <div className=\"text-muted-foreground p-4 text-center text-sm\">\n        No results found\n      </div>\n    )\n  }\n\n  return (\n    <ScrollArea\n      style={{\n        height:\n          items.length * Number(itemRefs.current[0]?.offsetHeight ?? 48) + 8,\n      }}\n      className=\"bg-popover max-h-[300px] overflow-auto rounded-md border p-1 shadow-md\"\n      onMouseMove={handleMouseMove}\n    >\n      {items.map((item, index) => (\n        <button\n          key={item.title}\n          ref={(el) => {\n            itemRefs.current[index] = el\n          }}\n          onClick={() => command(item)}\n          onMouseEnter={() => handleMouseEnter(index)}\n          className={cn(\n            \"relative flex w-full cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm transition-colors outline-none select-none\",\n            \"min-w-[256px]\",\n            index === selectedIndex\n              ? \"bg-accent text-accent-foreground\"\n              : \"hover:bg-accent hover:text-accent-foreground\"\n          )}\n        >\n          <div\n            className=\"border-border bg-background/40 flex size-8 items-center justify-center rounded-lg border\"\n            aria-hidden=\"true\"\n          >\n            <item.icon size={16} strokeWidth={2} className=\"opacity-60\" />\n          </div>\n          <div className=\"flex flex-col items-start\">\n            <span className=\"text-sm font-medium\">{item.title}</span>\n            <span className=\"text-muted-foreground text-xs\">\n              {item.description}\n            </span>\n          </div>\n        </button>\n      ))}\n    </ScrollArea>\n  )\n})\nEditorSlashMenuList.displayName = \"EditorSlashMenuList\"\n\n// =============================================================================\n// Slash Menu Suggestion\n// =============================================================================\n\nfunction createSlashMenuSuggestion(\n  items: SlashMenuItem[] = defaultSlashMenuItems\n): Omit<SuggestionOptions, \"editor\"> {\n  return {\n    char: \"/\",\n    items: ({ query }) => {\n      const normalizedQuery = query.toLowerCase()\n      return items.filter(\n        (item) =>\n          item.title.toLowerCase().includes(normalizedQuery) ||\n          item.searchTerms.some((term) => term.includes(normalizedQuery))\n      )\n    },\n    render: () => {\n      let component: ReactRenderer<SlashMenuListRef> | null = null\n      let popup: Instance<Props>[] | null = null\n\n      return {\n        onStart: (props) => {\n          component = new ReactRenderer(EditorSlashMenuList, {\n            props,\n            editor: props.editor,\n          })\n\n          if (!props.clientRect) return\n\n          popup = tippy(\"body\", {\n            getReferenceClientRect: props.clientRect as () => DOMRect,\n            appendTo: () => document.body,\n            content: component.element,\n            showOnCreate: true,\n            interactive: true,\n            trigger: \"manual\",\n            placement: \"bottom-start\",\n            animation: \"shift-toward-subtle\",\n            theme: \"slash-menu\",\n          })\n        },\n\n        onUpdate: (props) => {\n          component?.updateProps(props)\n\n          if (!props.clientRect || !popup?.[0]) return\n\n          popup[0].setProps({\n            getReferenceClientRect: props.clientRect as () => DOMRect,\n          })\n        },\n\n        onKeyDown: (props) => {\n          if (props.event.key === \"Escape\") {\n            popup?.[0]?.hide()\n            return true\n          }\n\n          return component?.ref?.onKeyDown(props.event) ?? false\n        },\n\n        onExit: () => {\n          popup?.[0]?.destroy()\n          component?.destroy()\n        },\n      }\n    },\n    command: ({ editor, range, props }) => {\n      // Delete the \"/\" trigger and any query text\n      editor.chain().focus().deleteRange(range).run()\n      // Execute the selected command\n      props.command(editor)\n    },\n  }\n}\n\n// =============================================================================\n// EditorSlashMenuExtension\n// =============================================================================\n\nexport interface EditorSlashMenuOptions {\n  items?: SlashMenuItem[]\n}\n\nexport const EditorSlashMenuExtension =\n  Extension.create<EditorSlashMenuOptions>({\n    name: \"slashMenu\",\n\n    addOptions() {\n      return {\n        items: defaultSlashMenuItems,\n      }\n    },\n\n    onCreate() {\n      injectSlashMenuStyles()\n    },\n\n    addProseMirrorPlugins() {\n      return [\n        Suggestion({\n          editor: this.editor,\n          ...createSlashMenuSuggestion(this.options.items),\n        }),\n      ]\n    },\n  })\n\n// =============================================================================\n// Slash Menu Styles (for tippy.js)\n// =============================================================================\n\nconst SLASH_MENU_STYLES = `\n  .tippy-box[data-theme~='slash-menu'] {\n    background-color: hsl(var(--popover));\n    border: 1px solid hsl(var(--border));\n    border-radius: 0.5rem;\n    box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\n    overflow: hidden;\n    min-width: 280px;\n  }\n  .tippy-box[data-theme~='slash-menu'] .tippy-content {\n    padding: 0;\n  }\n`\n\nconst STYLE_ID = \"editor-slash-menu-styles\"\n\nfunction injectSlashMenuStyles() {\n  if (typeof document === \"undefined\") return\n  if (document.getElementById(STYLE_ID)) return\n\n  const style = document.createElement(\"style\")\n  style.id = STYLE_ID\n  style.textContent = SLASH_MENU_STYLES\n  document.head.appendChild(style)\n}\n\n// =============================================================================\n// Exports\n// =============================================================================\n\nexport { createSlashMenuSuggestion, EditorSlashMenuList }\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-table.tsx",
      "content": "\"use client\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n  DropdownMenu,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { cn } from \"@/lib/utils\"\nimport { DropdownMenuContent as DropdownMenuContentPrimitive } from \"@radix-ui/react-dropdown-menu\"\nimport { Table } from \"@tiptap/extension-table\"\nimport { TableCell } from \"@tiptap/extension-table-cell\"\nimport { TableHeader } from \"@tiptap/extension-table-header\"\nimport { TableRow } from \"@tiptap/extension-table-row\"\nimport { BubbleMenu, useEditorState, type Editor } from \"@tiptap/react\"\nimport { Table as TableIcon } from \"lucide-react\"\nimport {\n  AlignCenter,\n  AlignLeft,\n  AlignRight,\n  AlignVerticalJustifyCenter,\n  AlignVerticalJustifyEnd,\n  AlignVerticalJustifyStart,\n  ArrowDownToLine,\n  ArrowLeftToLine,\n  ArrowRightToLine,\n  ArrowUpToLine,\n  ChevronDown,\n  Columns3,\n  Combine,\n  Rows3,\n  Split,\n  TableProperties,\n  Trash2,\n} from \"lucide-react\"\nimport * as React from \"react\"\nimport { EditorContext, createEditorExtension } from \"./editor\"\n\n// =============================================================================\n// EditorTableExtension\n// =============================================================================\n\nexport interface EditorTableOptions {\n  resizable?: boolean\n  HTMLAttributes?: Record<string, unknown>\n}\n\nexport const EditorTableExtension = Table.configure({\n  resizable: true,\n  HTMLAttributes: {\n    class: cn(\n      \"w-full caption-bottom text-sm my-4 border border-border\",\n      \"border-collapse table-fixed\",\n      // Resize cursor when resizing\n      \"[&.resize-cursor]:cursor-col-resize\"\n    ),\n  },\n})\n\nexport const EditorTableRowExtension = TableRow.configure({\n  HTMLAttributes: {\n    class:\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n  },\n})\n\nexport const EditorTableHeaderExtension = TableHeader.extend({\n  addAttributes() {\n    return {\n      ...this.parent?.(),\n      textAlign: {\n        default: null,\n        parseHTML: (element) =>\n          element.style.textAlign || element.getAttribute(\"data-text-align\"),\n        renderHTML: (attributes) => {\n          if (!attributes.textAlign) return {}\n          return {\n            style: `text-align: ${attributes.textAlign}`,\n            \"data-text-align\": attributes.textAlign,\n          }\n        },\n      },\n      verticalAlign: {\n        default: null,\n        parseHTML: (element) =>\n          element.style.verticalAlign ||\n          element.getAttribute(\"data-vertical-align\"),\n        renderHTML: (attributes) => {\n          if (!attributes.verticalAlign) return {}\n          return {\n            style: `vertical-align: ${attributes.verticalAlign}`,\n            \"data-vertical-align\": attributes.verticalAlign,\n          }\n        },\n      },\n    }\n  },\n}).configure({\n  HTMLAttributes: {\n    class: cn(\n      \"h-10 px-2 text-left align-middle font-medium text-muted-foreground\",\n      \"border-b border-r last:border-r-0 bg-muted/10\",\n      \"relative box-border min-w-[1em]\",\n      \"[&>p]:m-0\",\n      // Selected cell overlay using Tailwind after: pseudo-element\n      \"[&.selectedCell]:after:content-[''] [&.selectedCell]:after:absolute [&.selectedCell]:after:inset-0\",\n      \"[&.selectedCell]:after:bg-primary [&.selectedCell]:after:opacity-[0.08] [&.selectedCell]:after:pointer-events-none\"\n    ),\n  },\n})\n\nexport const EditorTableCellExtension = TableCell.extend({\n  addAttributes() {\n    return {\n      ...this.parent?.(),\n      textAlign: {\n        default: null,\n        parseHTML: (element) =>\n          element.style.textAlign || element.getAttribute(\"data-text-align\"),\n        renderHTML: (attributes) => {\n          if (!attributes.textAlign) return {}\n          return {\n            style: `text-align: ${attributes.textAlign}`,\n            \"data-text-align\": attributes.textAlign,\n          }\n        },\n      },\n      verticalAlign: {\n        default: null,\n        parseHTML: (element) =>\n          element.style.verticalAlign ||\n          element.getAttribute(\"data-vertical-align\"),\n        renderHTML: (attributes) => {\n          if (!attributes.verticalAlign) return {}\n          return {\n            style: `vertical-align: ${attributes.verticalAlign}`,\n            \"data-vertical-align\": attributes.verticalAlign,\n          }\n        },\n      },\n    }\n  },\n}).configure({\n  HTMLAttributes: {\n    class: cn(\n      \"p-2 align-middle border-b\",\n      \"[&:not(:last-child)]:border-r\",\n      \"relative box-border min-w-[1em]\",\n      \"[&>p]:m-0\",\n      // Selected cell overlay using Tailwind after: pseudo-element\n      \"[&.selectedCell]:after:content-[''] [&.selectedCell]:after:absolute [&.selectedCell]:after:inset-0\",\n      \"[&.selectedCell]:after:bg-primary [&.selectedCell]:after:opacity-[0.08] [&.selectedCell]:after:pointer-events-none\"\n    ),\n  },\n})\n\nexport const EditorTableExtensions = createEditorExtension({\n  extension: [\n    EditorTableExtension,\n    EditorTableRowExtension,\n    EditorTableHeaderExtension,\n    EditorTableCellExtension,\n  ],\n  bubbleMenu: EditorBubbleMenuTable,\n  commands: [\n    {\n      key: \"insertTable\",\n      icon: TableIcon,\n      label: \"Insert Table\",\n      description: \"Insert a new table\",\n      execute: (editor: Editor) =>\n        editor\n          .chain()\n          .focus()\n          .insertTable({ rows: 3, cols: 3, withHeaderRow: true })\n          .run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().insertTable({ rows: 3, cols: 3 }).run(),\n    },\n    {\n      key: \"addColumnBefore\",\n      label: \"Add Column Before\",\n      execute: (editor: Editor) =>\n        editor.chain().focus().addColumnBefore().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().addColumnBefore().run(),\n    },\n    {\n      key: \"addColumnAfter\",\n      label: \"Add Column After\",\n      execute: (editor: Editor) =>\n        editor.chain().focus().addColumnAfter().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().addColumnAfter().run(),\n    },\n    {\n      key: \"deleteColumn\",\n      label: \"Delete Column\",\n      execute: (editor: Editor) => editor.chain().focus().deleteColumn().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().deleteColumn().run(),\n    },\n    {\n      key: \"addRowBefore\",\n      label: \"Add Row Before\",\n      execute: (editor: Editor) => editor.chain().focus().addRowBefore().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().addRowBefore().run(),\n    },\n    {\n      key: \"addRowAfter\",\n      label: \"Add Row After\",\n      execute: (editor: Editor) => editor.chain().focus().addRowAfter().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().addRowAfter().run(),\n    },\n    {\n      key: \"deleteRow\",\n      label: \"Delete Row\",\n      execute: (editor: Editor) => editor.chain().focus().deleteRow().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().deleteRow().run(),\n    },\n    {\n      key: \"deleteTable\",\n      label: \"Delete Table\",\n      execute: (editor: Editor) => editor.chain().focus().deleteTable().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().deleteTable().run(),\n    },\n    {\n      key: \"mergeCells\",\n      label: \"Merge Cells\",\n      execute: (editor: Editor) => editor.chain().focus().mergeCells().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().mergeCells().run(),\n    },\n    {\n      key: \"splitCell\",\n      label: \"Split Cell\",\n      execute: (editor: Editor) => editor.chain().focus().splitCell().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().splitCell().run(),\n    },\n    {\n      key: \"toggleHeaderColumn\",\n      label: \"Toggle Header Column\",\n      execute: (editor: Editor) =>\n        editor.chain().focus().toggleHeaderColumn().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().toggleHeaderColumn().run(),\n    },\n    {\n      key: \"toggleHeaderRow\",\n      label: \"Toggle Header Row\",\n      execute: (editor: Editor) =>\n        editor.chain().focus().toggleHeaderRow().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().toggleHeaderRow().run(),\n    },\n    {\n      key: \"toggleHeaderCell\",\n      label: \"Toggle Header Cell\",\n      execute: (editor: Editor) =>\n        editor.chain().focus().toggleHeaderCell().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().toggleHeaderCell().run(),\n    },\n    {\n      key: \"mergeOrSplit\",\n      label: \"Merge or Split\",\n      execute: (editor: Editor) => editor.chain().focus().mergeOrSplit().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().mergeOrSplit().run(),\n    },\n    {\n      key: \"goToNextCell\",\n      label: \"Go to Next Cell\",\n      execute: (editor: Editor) => editor.chain().focus().goToNextCell().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().goToNextCell().run(),\n    },\n    {\n      key: \"goToPreviousCell\",\n      label: \"Go to Previous Cell\",\n      execute: (editor: Editor) =>\n        editor.chain().focus().goToPreviousCell().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().goToPreviousCell().run(),\n    },\n  ],\n})\n\n// =============================================================================\n// EditorBubbleMenuTable\n// =============================================================================\n\nexport interface EditorBubbleMenuTableProps extends Omit<\n  React.ComponentProps<typeof BubbleMenu>,\n  \"editor\" | \"children\"\n> {}\n\nexport function EditorBubbleMenuTable(props: EditorBubbleMenuTableProps) {\n  const ctx = React.useContext(EditorContext)\n  const editor = ctx?.editor\n\n  const {\n    canMergeCells = false,\n    canSplitCell = false,\n    canDeleteColumn = false,\n    canDeleteRow = false,\n  } = useEditorState({\n    editor: editor ?? null,\n    selector: ({\n      editor: e,\n    }): {\n      canMergeCells: boolean\n      canSplitCell: boolean\n      canDeleteColumn: boolean\n      canDeleteRow: boolean\n    } => {\n      if (!e) {\n        return {\n          canMergeCells: false,\n          canSplitCell: false,\n          canDeleteColumn: false,\n          canDeleteRow: false,\n        }\n      }\n      return {\n        canMergeCells: e.can().mergeCells(),\n        canSplitCell: e.can().splitCell(),\n        canDeleteColumn: e.can().deleteColumn(),\n        canDeleteRow: e.can().deleteRow(),\n      }\n    },\n  }) ?? {}\n\n  if (!editor) return null\n\n  return (\n    <BubbleMenu\n      {...props}\n      editor={editor}\n      tippyOptions={{\n        duration: 100,\n        placement: \"bottom\",\n        getReferenceClientRect: () => {\n          const { view, state } = editor\n          const domAtPos = view.domAtPos(state.selection.from)\n          const node = domAtPos.node\n          const tableElement =\n            node instanceof Element\n              ? node.closest(\"table\")\n              : node.parentElement?.closest(\"table\")\n          if (tableElement) {\n            return tableElement.getBoundingClientRect()\n          }\n          return view.dom.getBoundingClientRect()\n        },\n      }}\n      shouldShow={({ editor: e }) => e.isActive(\"table\")}\n      className=\"w-fit\"\n    >\n      <div className=\"bg-popover flex items-center gap-0.5 rounded-md border p-0.5 shadow-md\">\n        {/* Column Actions */}\n        <DropdownMenu modal={false}>\n          <DropdownMenuTrigger asChild>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-7 gap-1 px-2 text-xs\"\n            >\n              <Columns3 className=\"size-3.5\" />\n              Column\n              <ChevronDown className=\"size-3 opacity-50\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContentPrimitive\n            align=\"start\"\n            sideOffset={8}\n            className={cn(\n              \"min-w-[160px]\",\n              \"bg-popover text-popover-foreground z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md\",\n              \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\"\n            )}\n          >\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().toggleHeaderColumn().run()}\n            >\n              <TableProperties className=\"mr-2 size-3.5\" />\n              Toggle Header\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().addColumnBefore().run()}\n            >\n              <ArrowLeftToLine className=\"mr-2 size-3.5\" />\n              Insert Before\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().addColumnAfter().run()}\n            >\n              <ArrowRightToLine className=\"mr-2 size-3.5\" />\n              Insert After\n            </DropdownMenuItem>\n            <div className=\"bg-border my-1 h-px\" />\n            <DropdownMenuItem\n              onClick={() =>\n                editor\n                  .chain()\n                  .focus()\n                  .setCellAttribute(\"textAlign\", \"left\")\n                  .run()\n              }\n            >\n              <AlignLeft className=\"mr-2 size-3.5\" />\n              Align Left\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() =>\n                editor\n                  .chain()\n                  .focus()\n                  .setCellAttribute(\"textAlign\", \"center\")\n                  .run()\n              }\n            >\n              <AlignCenter className=\"mr-2 size-3.5\" />\n              Align Center\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() =>\n                editor\n                  .chain()\n                  .focus()\n                  .setCellAttribute(\"textAlign\", \"right\")\n                  .run()\n              }\n            >\n              <AlignRight className=\"mr-2 size-3.5\" />\n              Align Right\n            </DropdownMenuItem>\n            <div className=\"bg-border my-1 h-px\" />\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().deleteColumn().run()}\n              className=\"text-destructive focus:text-destructive\"\n            >\n              <Trash2 className=\"mr-2 size-3.5\" />\n              Delete Column\n            </DropdownMenuItem>\n          </DropdownMenuContentPrimitive>\n        </DropdownMenu>\n\n        {/* Row Actions */}\n        <DropdownMenu modal={false}>\n          <DropdownMenuTrigger asChild>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-7 gap-1 px-2 text-xs\"\n            >\n              <Rows3 className=\"size-3.5\" />\n              Row\n              <ChevronDown className=\"size-3 opacity-50\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContentPrimitive\n            align=\"start\"\n            sideOffset={8}\n            className={cn(\n              \"min-w-[160px]\",\n              \"bg-popover text-popover-foreground z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md\",\n              \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\"\n            )}\n          >\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().toggleHeaderRow().run()}\n            >\n              <TableProperties className=\"mr-2 size-3.5\" />\n              Toggle Header\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().addRowBefore().run()}\n            >\n              <ArrowUpToLine className=\"mr-2 size-3.5\" />\n              Insert Above\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().addRowAfter().run()}\n            >\n              <ArrowDownToLine className=\"mr-2 size-3.5\" />\n              Insert Below\n            </DropdownMenuItem>\n\n            <div className=\"bg-border my-1 h-px\" />\n            <DropdownMenuItem\n              onClick={() =>\n                editor\n                  .chain()\n                  .focus()\n                  .setCellAttribute(\"verticalAlign\", \"top\")\n                  .run()\n              }\n            >\n              <AlignVerticalJustifyStart className=\"mr-2 size-3.5\" />\n              Align Top\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() =>\n                editor\n                  .chain()\n                  .focus()\n                  .setCellAttribute(\"verticalAlign\", \"middle\")\n                  .run()\n              }\n            >\n              <AlignVerticalJustifyCenter className=\"mr-2 size-3.5\" />\n              Align Middle\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() =>\n                editor\n                  .chain()\n                  .focus()\n                  .setCellAttribute(\"verticalAlign\", \"bottom\")\n                  .run()\n              }\n            >\n              <AlignVerticalJustifyEnd className=\"mr-2 size-3.5\" />\n              Align Bottom\n            </DropdownMenuItem>\n            <div className=\"bg-border my-1 h-px\" />\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().deleteRow().run()}\n              className=\"text-destructive focus:text-destructive\"\n            >\n              <Trash2 className=\"mr-2 size-3.5\" />\n              Delete Row\n            </DropdownMenuItem>\n          </DropdownMenuContentPrimitive>\n        </DropdownMenu>\n\n        {/* Cell Actions */}\n        <DropdownMenu modal={false}>\n          <DropdownMenuTrigger asChild>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-7 gap-1 px-2 text-xs\"\n            >\n              <Combine className=\"size-3.5\" />\n              Cell\n              <ChevronDown className=\"size-3 opacity-50\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContentPrimitive\n            align=\"start\"\n            sideOffset={8}\n            className={cn(\n              \"min-w-[160px]\",\n              \"bg-popover text-popover-foreground z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-md\",\n              \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\"\n            )}\n          >\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().mergeCells().run()}\n              disabled={!canMergeCells}\n            >\n              <Combine className=\"mr-2 size-3.5\" />\n              Merge Cells\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().splitCell().run()}\n              disabled={!canSplitCell}\n            >\n              <Split className=\"mr-2 size-3.5\" />\n              Split Cell\n            </DropdownMenuItem>\n            <DropdownMenuItem\n              onClick={() => editor.chain().focus().toggleHeaderCell().run()}\n            >\n              <TableProperties className=\"mr-2 size-3.5\" />\n              Toggle Header Cell\n            </DropdownMenuItem>\n          </DropdownMenuContentPrimitive>\n        </DropdownMenu>\n\n        {/* Quick Delete Actions */}\n        <div className=\"ml-0.5 flex items-center gap-0.5 border-l pl-1\">\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"text-destructive hover:text-destructive hover:bg-destructive/10 h-7 gap-1 px-2 text-xs\"\n            onClick={() => editor.chain().focus().deleteColumn().run()}\n            disabled={!canDeleteColumn}\n            title=\"Delete Column\"\n          >\n            <Columns3 className=\"size-3.5\" />\n          </Button>\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"text-destructive hover:text-destructive hover:bg-destructive/10 h-7 gap-1 px-2 text-xs\"\n            onClick={() => editor.chain().focus().deleteRow().run()}\n            disabled={!canDeleteRow}\n            title=\"Delete Row\"\n          >\n            <Rows3 className=\"size-3.5\" />\n          </Button>\n        </div>\n\n        {/* Delete Table */}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          className=\"text-destructive hover:text-destructive hover:bg-destructive/10 h-7 w-7 p-0\"\n          onClick={() => editor.chain().focus().deleteTable().run()}\n          title=\"Delete Table\"\n        >\n          <Trash2 className=\"size-3.5\" />\n        </Button>\n      </div>\n    </BubbleMenu>\n  )\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/editor/editor-task-list.tsx",
      "content": "\"use client\"\n\nimport type { Editor } from \"@tiptap/react\"\nimport TaskItem from \"@tiptap/extension-task-item\"\nimport TaskList from \"@tiptap/extension-task-list\"\nimport { CheckSquare } from \"lucide-react\"\nimport { createEditorExtension } from \"./editor\"\n\n// =============================================================================\n// EditorTaskListExtension\n// =============================================================================\n\nconst EditorTaskListNode = TaskList.configure({\n  HTMLAttributes: {\n    class: \"not-prose pl-0 list-none\",\n  },\n})\n\n// =============================================================================\n// EditorTaskItemExtension\n// =============================================================================\n\nconst EditorTaskItemNode = TaskItem.configure({\n  nested: true,\n  HTMLAttributes: {\n    class: \"flex items-start gap-2 [&>label]:mt-0.5\",\n  },\n})\n\n// =============================================================================\n// EditorTaskListExtensions\n// =============================================================================\n\nexport const EditorTaskListExtensions = createEditorExtension({\n  extension: [EditorTaskListNode, EditorTaskItemNode],\n  commands: [\n    {\n      key: \"taskList\",\n      icon: CheckSquare,\n      label: \"Task List\",\n      description: \"Create a task list with checkboxes\",\n      execute: (editor: Editor) =>\n        editor.chain().focus().toggleTaskList().run(),\n      canExecute: (editor: Editor) =>\n        editor.can().chain().focus().toggleTaskList().run(),\n      isActive: (editor: Editor) => editor.isActive(\"taskList\"),\n    },\n  ],\n})\n\n// Export individual extensions for backward compatibility\nexport const EditorTaskListExtension = EditorTaskListNode\nexport const EditorTaskItemExtension = EditorTaskItemNode\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:block"
}