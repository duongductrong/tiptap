{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "editor-image",
  "title": "Editor Image Extension",
  "description": "Image extension with upload, resize, alignment, captions, and bubble menu.",
  "dependencies": [],
  "registryDependencies": [
    "editor",
    "tabs"
  ],
  "files": [
    {
      "path": "src/registry/editor/editor-image.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { Node, mergeAttributes } from \"@tiptap/core\"\nimport {\n  BubbleMenu,\n  NodeViewWrapper,\n  ReactNodeViewRenderer,\n} from \"@tiptap/react\"\nimport { EditorContext, type EditorContextValue } from \"./editor\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  DropdownMenu,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { DropdownMenuContent as DropdownMenuContentPrimitive } from \"@radix-ui/react-dropdown-menu\"\nimport { Input } from \"@/components/ui/input\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\"\nimport { cn } from \"@/lib/utils\"\nimport {\n  AlertCircle,\n  AlignCenter,\n  AlignLeft,\n  AlignRight,\n  Check,\n  ChevronDown,\n  ImageUp,\n  Link2,\n  Loader2,\n  Lock,\n  LockOpen,\n  MessageSquare,\n  Trash2,\n  Upload,\n  X,\n} from \"lucide-react\"\n\n// =============================================================================\n// Types & Configuration\n// =============================================================================\n\nexport type EditorImageUploadStrategy = \"base64\" | \"server\" | \"url\"\nexport type EditorImageAlignment = \"left\" | \"center\" | \"right\"\nexport type EditorImageObjectFit =\n  | \"contain\"\n  | \"cover\"\n  | \"fill\"\n  | \"none\"\n  | \"scale-down\"\n\nexport interface EditorImageConfig {\n  uploadStrategy?: EditorImageUploadStrategy\n  onUpload?: (file: File) => Promise<string>\n  maxFileSize?: number\n  acceptedTypes?: string[]\n  onError?: (error: Error) => void\n}\n\nconst DEFAULT_CONFIG: Required<\n  Omit<EditorImageConfig, \"onUpload\" | \"onError\">\n> = {\n  uploadStrategy: \"base64\",\n  maxFileSize: 5 * 1024 * 1024, // 5MB\n  acceptedTypes: [\"image/jpeg\", \"image/png\", \"image/gif\", \"image/webp\"],\n}\n\n// =============================================================================\n// Context\n// =============================================================================\n\ninterface EditorImageContextType extends EditorImageConfig {\n  isUploading: boolean\n  setIsUploading: (value: boolean) => void\n  error: string | null\n  setError: (value: string | null) => void\n}\n\nconst EditorImageContext = React.createContext<EditorImageContextType | null>(\n  null\n)\n\n// =============================================================================\n// Utility Functions\n// =============================================================================\n\nfunction formatFileSize(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`\n  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`\n}\n\nasync function convertToBase64(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onload = () => resolve(reader.result as string)\n    reader.onerror = reject\n    reader.readAsDataURL(file)\n  })\n}\n\nfunction validateFile(\n  file: File,\n  config: Pick<EditorImageConfig, \"maxFileSize\" | \"acceptedTypes\">\n): string | null {\n  const maxSize = config.maxFileSize ?? DEFAULT_CONFIG.maxFileSize\n  const acceptedTypes = config.acceptedTypes ?? DEFAULT_CONFIG.acceptedTypes\n\n  if (!acceptedTypes.includes(file.type)) {\n    return `Invalid file type. Accepted: ${acceptedTypes.map((t) => t.split(\"/\")[1]).join(\", \")}`\n  }\n\n  if (file.size > maxSize) {\n    return `File too large. Maximum size: ${formatFileSize(maxSize)}`\n  }\n\n  return null\n}\n\n// =============================================================================\n// EditorImagePlaceholder - Upload UI shown when src is empty\n// =============================================================================\n\ninterface EditorImagePlaceholderProps {\n  onImageReady: (src: string, alt?: string) => void\n  config: EditorImageConfig\n}\n\nexport function EditorImagePlaceholder({\n  onImageReady,\n  config,\n}: EditorImagePlaceholderProps) {\n  const [isUploading, setIsUploading] = React.useState(false)\n  const [error, setError] = React.useState<string | null>(null)\n  const [activeTab, setActiveTab] = React.useState<string>(\"upload\")\n\n  const contextValue: EditorImageContextType = {\n    ...config,\n    isUploading,\n    setIsUploading,\n    error,\n    setError,\n  }\n\n  const handleUpload = React.useCallback(\n    async (file: File) => {\n      setError(null)\n\n      const validationError = validateFile(file, config)\n      if (validationError) {\n        setError(validationError)\n        return\n      }\n\n      setIsUploading(true)\n\n      try {\n        let src: string\n\n        const strategy = config.uploadStrategy ?? DEFAULT_CONFIG.uploadStrategy\n\n        if (strategy === \"server\" && config.onUpload) {\n          src = await config.onUpload(file)\n        } else {\n          src = await convertToBase64(file)\n        }\n\n        onImageReady(src, file.name)\n      } catch (err) {\n        const message = err instanceof Error ? err.message : \"Upload failed\"\n        setError(message)\n        config.onError?.(err instanceof Error ? err : new Error(message))\n      } finally {\n        setIsUploading(false)\n      }\n    },\n    [config, onImageReady]\n  )\n\n  const handleUrlSubmit = React.useCallback(\n    (url: string) => {\n      if (!url.trim()) {\n        setError(\"Please enter a valid URL\")\n        return\n      }\n\n      try {\n        new URL(url)\n        onImageReady(url)\n      } catch {\n        setError(\"Please enter a valid URL\")\n      }\n    },\n    [onImageReady]\n  )\n\n  return (\n    <EditorImageContext.Provider value={contextValue}>\n      <div className=\"border-border bg-muted/30 my-4 rounded-lg border\">\n        <Tabs value={activeTab} onValueChange={setActiveTab}>\n          <TabsList className=\"ml-2 mt-2\">\n            <TabsTrigger value=\"upload\">\n              <Upload className=\"mr-2 size-4\" />\n              Upload\n            </TabsTrigger>\n            <TabsTrigger value=\"embed\">\n              <Link2 className=\"mr-2 size-4\" />\n              Embed link\n            </TabsTrigger>\n          </TabsList>\n\n          <div className=\"p-4\">\n            {error && (\n              <div className=\"bg-destructive/10 text-destructive mb-4 flex items-center gap-2 rounded-md p-3 text-sm\">\n                <AlertCircle className=\"size-4 shrink-0\" />\n                <span>{error}</span>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  className=\"ml-auto h-6 w-6 p-0\"\n                  onClick={() => setError(null)}\n                >\n                  <X className=\"size-3\" />\n                </Button>\n              </div>\n            )}\n\n            <TabsContent value=\"upload\" className=\"mt-0\">\n              <EditorImageUploadZone\n                onUpload={handleUpload}\n                disabled={isUploading}\n              />\n              <p className=\"text-muted-foreground mt-3 text-center text-xs\">\n                Maximum file size:{\" \"}\n                {formatFileSize(\n                  config.maxFileSize ?? DEFAULT_CONFIG.maxFileSize\n                )}\n              </p>\n            </TabsContent>\n\n            <TabsContent value=\"embed\" className=\"mt-0\">\n              <EditorImageUrlInput\n                onSubmit={handleUrlSubmit}\n                disabled={isUploading}\n              />\n            </TabsContent>\n          </div>\n        </Tabs>\n      </div>\n    </EditorImageContext.Provider>\n  )\n}\n\n// =============================================================================\n// EditorImageUploadZone - Drag & drop file upload\n// =============================================================================\n\ninterface EditorImageUploadZoneProps {\n  onUpload: (file: File) => void\n  disabled?: boolean\n}\n\nexport function EditorImageUploadZone({\n  onUpload,\n  disabled,\n}: EditorImageUploadZoneProps) {\n  const [isDragOver, setIsDragOver] = React.useState(false)\n  const inputRef = React.useRef<HTMLInputElement>(null)\n  const ctx = React.useContext(EditorImageContext)\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    if (!disabled) setIsDragOver(true)\n  }\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    setIsDragOver(false)\n  }\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    setIsDragOver(false)\n\n    if (disabled) return\n\n    const file = e.dataTransfer.files[0]\n    if (file) onUpload(file)\n  }\n\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0]\n    if (file) onUpload(file)\n    if (inputRef.current) inputRef.current.value = \"\"\n  }\n\n  return (\n    <div\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n      className={cn(\n        \"flex flex-col items-center justify-center rounded-lg border-2 border-dashed p-8 transition-colors\",\n        isDragOver\n          ? \"border-primary bg-primary/5\"\n          : \"border-muted-foreground/25 hover:border-muted-foreground/50\",\n        disabled && \"pointer-events-none opacity-50\"\n      )}\n    >\n      <input\n        ref={inputRef}\n        type=\"file\"\n        accept=\"image/*\"\n        onChange={handleFileSelect}\n        className=\"hidden\"\n        disabled={disabled}\n      />\n\n      {ctx?.isUploading ? (\n        <>\n          <Loader2 className=\"text-muted-foreground size-8 animate-spin\" />\n          <p className=\"text-muted-foreground mt-2 text-sm\">Uploading...</p>\n        </>\n      ) : (\n        <>\n          <ImageUp className=\"text-muted-foreground size-8\" />\n          <Button\n            variant=\"outline\"\n            className=\"mt-4\"\n            onClick={() => inputRef.current?.click()}\n            disabled={disabled}\n          >\n            Upload file\n          </Button>\n          <p className=\"text-muted-foreground mt-2 text-sm\">\n            or drag and drop an image here\n          </p>\n        </>\n      )}\n    </div>\n  )\n}\n\n// =============================================================================\n// EditorImageUrlInput - External URL input\n// =============================================================================\n\ninterface EditorImageUrlInputProps {\n  onSubmit: (url: string) => void\n  disabled?: boolean\n}\n\nexport function EditorImageUrlInput({\n  onSubmit,\n  disabled,\n}: EditorImageUrlInputProps) {\n  const [url, setUrl] = React.useState(\"\")\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault()\n    onSubmit(url)\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault()\n      onSubmit(url)\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit} className=\"flex gap-2\">\n      <Input\n        type=\"url\"\n        placeholder=\"Paste image URL...\"\n        value={url}\n        onChange={(e) => setUrl(e.target.value)}\n        onKeyDown={handleKeyDown}\n        disabled={disabled}\n        className=\"flex-1\"\n      />\n      <Button type=\"submit\" disabled={disabled || !url.trim()}>\n        Embed\n      </Button>\n    </form>\n  )\n}\n\n// =============================================================================\n// Resize Handle Component\n// =============================================================================\n\ntype ResizeDirection = \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\"\n\ninterface ResizeHandleProps {\n  direction: ResizeDirection\n  onResizeStart: (e: React.MouseEvent, direction: ResizeDirection) => void\n}\n\nfunction ResizeHandle({ direction, onResizeStart }: ResizeHandleProps) {\n  const positionClasses: Record<ResizeDirection, string> = {\n    \"top-left\": \"-left-1.5 -top-1.5 cursor-nwse-resize\",\n    \"top-right\": \"-right-1.5 -top-1.5 cursor-nesw-resize\",\n    \"bottom-left\": \"-bottom-1.5 -left-1.5 cursor-nesw-resize\",\n    \"bottom-right\": \"-bottom-1.5 -right-1.5 cursor-nwse-resize\",\n  }\n\n  return (\n    <div\n      className={cn(\n        \"border-primary bg-background absolute size-3 border-2 transition-transform hover:scale-125\",\n        positionClasses[direction]\n      )}\n      onMouseDown={(e) => onResizeStart(e, direction)}\n    />\n  )\n}\n\n// =============================================================================\n// EditorImageBlock - Rendered image with styling\n// =============================================================================\n\ninterface EditorImageBlockProps extends React.ComponentProps<\"img\"> {\n  selected?: boolean\n  imageWidth?: number | string | null\n  imageHeight?: number | string | null\n  objectFit?: EditorImageObjectFit | null\n}\n\nexport const EditorImageBlock = React.forwardRef<\n  HTMLImageElement,\n  EditorImageBlockProps\n>(\n  (\n    {\n      className,\n      selected,\n      imageWidth,\n      imageHeight,\n      objectFit,\n      style,\n      ...props\n    },\n    ref\n  ) => {\n    return (\n      <img\n        ref={ref}\n        {...props}\n        className={cn(\n          \"max-w-full\",\n          selected && \"ring-primary ring-1 ring-offset-1\",\n          className\n        )}\n        style={{\n          margin: 0,\n          ...style,\n          width: imageWidth\n            ? typeof imageWidth === \"string\" && imageWidth.includes(\"%\")\n              ? imageWidth\n              : `${imageWidth}px`\n            : undefined,\n          height: imageHeight\n            ? typeof imageHeight === \"string\" && imageHeight.includes(\"%\")\n              ? imageHeight\n              : `${imageHeight}px`\n            : undefined,\n          objectFit: objectFit ?? undefined,\n        }}\n      />\n    )\n  }\n)\nEditorImageBlock.displayName = \"EditorImageBlock\"\n\n// =============================================================================\n// ImageNodeView - Main NodeView component\n// =============================================================================\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction ImageNodeView(props: any) {\n  const { node, updateAttributes, selected, extension } = props\n\n  const nodeAttrs = node.attrs as {\n    src: string | null\n    alt: string | null\n    title: string | null\n    width: number | string | null\n    height: number | string | null\n    alignment: EditorImageAlignment\n    caption: string | null\n    objectFit: EditorImageObjectFit\n    lockAspectRatio: boolean\n  }\n\n  const hasSrc = !!nodeAttrs.src\n  const imageRef = React.useRef<HTMLImageElement>(null)\n  const containerRef = React.useRef<HTMLDivElement>(null)\n\n  const [isResizing, setIsResizing] = React.useState(false)\n  const [resizeDirection, setResizeDirection] =\n    React.useState<ResizeDirection | null>(null)\n  const [initialSize, setInitialSize] = React.useState({ width: 0, height: 0 })\n  const [initialMousePos, setInitialMousePos] = React.useState({ x: 0, y: 0 })\n  const [currentSize, setCurrentSize] = React.useState<{\n    width: number\n    height: number\n  } | null>(null)\n\n  const handleImageReady = (src: string, alt?: string) => {\n    updateAttributes({ src, alt: alt ?? nodeAttrs.alt })\n  }\n\n  const handleResizeStart = React.useCallback(\n    (e: React.MouseEvent, direction: ResizeDirection) => {\n      e.preventDefault()\n      e.stopPropagation()\n\n      if (!imageRef.current) return\n\n      const rect = imageRef.current.getBoundingClientRect()\n      setIsResizing(true)\n      setResizeDirection(direction)\n      setInitialSize({\n        width: rect.width,\n        height: rect.height,\n      })\n      setInitialMousePos({ x: e.clientX, y: e.clientY })\n      setCurrentSize({ width: rect.width, height: rect.height })\n    },\n    []\n  )\n\n  React.useEffect(() => {\n    if (!isResizing) return\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!resizeDirection) return\n\n      const deltaX = e.clientX - initialMousePos.x\n      const deltaY = e.clientY - initialMousePos.y\n\n      let newWidth = initialSize.width\n      let newHeight = initialSize.height\n\n      if (resizeDirection.includes(\"right\")) newWidth += deltaX\n      if (resizeDirection.includes(\"left\")) newWidth -= deltaX\n      if (resizeDirection.includes(\"bottom\")) newHeight += deltaY\n      if (resizeDirection.includes(\"top\")) newHeight -= deltaY\n\n      const shouldLockRatio = e.shiftKey || nodeAttrs.lockAspectRatio\n      if (shouldLockRatio && initialSize.width > 0 && initialSize.height > 0) {\n        const aspectRatio = initialSize.width / initialSize.height\n        const containerMaxWidth =\n          containerRef.current?.parentElement?.clientWidth ?? Infinity\n\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n          newWidth = Math.min(newWidth, containerMaxWidth)\n          newHeight = newWidth / aspectRatio\n        } else {\n          newWidth = newHeight * aspectRatio\n          if (newWidth > containerMaxWidth) {\n            newWidth = containerMaxWidth\n            newHeight = newWidth / aspectRatio\n          }\n        }\n      }\n\n      newWidth = Math.max(50, newWidth)\n      newHeight = Math.max(50, newHeight)\n\n      setCurrentSize({\n        width: Math.round(newWidth),\n        height: Math.round(newHeight),\n      })\n    }\n\n    const handleMouseUp = () => {\n      if (currentSize) {\n        updateAttributes({\n          width: currentSize.width,\n          height: currentSize.height,\n        })\n      }\n      setIsResizing(false)\n      setResizeDirection(null)\n      setCurrentSize(null)\n    }\n\n    document.addEventListener(\"mousemove\", handleMouseMove)\n    document.addEventListener(\"mouseup\", handleMouseUp)\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove)\n      document.removeEventListener(\"mouseup\", handleMouseUp)\n    }\n  }, [\n    isResizing,\n    resizeDirection,\n    initialMousePos,\n    initialSize,\n    currentSize,\n    updateAttributes,\n    nodeAttrs.lockAspectRatio,\n  ])\n\n  const displayWidth = currentSize?.width ?? nodeAttrs.width\n  const displayHeight = currentSize?.height ?? nodeAttrs.height\n\n  const alignmentClasses: Record<EditorImageAlignment, string> = {\n    left: \"items-start\",\n    center: \"items-center\",\n    right: \"items-end\",\n  }\n\n  return (\n    <NodeViewWrapper\n      data-type=\"image\"\n      data-src={nodeAttrs.src ?? undefined}\n      data-alt={nodeAttrs.alt ?? undefined}\n      data-title={nodeAttrs.title ?? undefined}\n      data-alignment={nodeAttrs.alignment}\n    >\n      {hasSrc ? (\n        <figure\n          className={cn(\n            \"my-4 flex w-full flex-col\",\n            alignmentClasses[nodeAttrs.alignment]\n          )}\n        >\n          <div\n            ref={containerRef}\n            className={cn(\n              \"group relative inline-block\",\n              isResizing && \"select-none\"\n            )}\n          >\n            <EditorImageBlock\n              ref={imageRef}\n              src={nodeAttrs.src!}\n              alt={nodeAttrs.alt ?? undefined}\n              title={nodeAttrs.title ?? undefined}\n              selected={selected}\n              imageWidth={displayWidth}\n              imageHeight={displayHeight}\n              objectFit={nodeAttrs.objectFit}\n              draggable={!isResizing}\n            />\n            {selected && (\n              <>\n                <ResizeHandle\n                  direction=\"top-left\"\n                  onResizeStart={handleResizeStart}\n                />\n                <ResizeHandle\n                  direction=\"top-right\"\n                  onResizeStart={handleResizeStart}\n                />\n                <ResizeHandle\n                  direction=\"bottom-left\"\n                  onResizeStart={handleResizeStart}\n                />\n                <ResizeHandle\n                  direction=\"bottom-right\"\n                  onResizeStart={handleResizeStart}\n                />\n              </>\n            )}\n            {isResizing && currentSize && (\n              <div className=\"absolute bottom-2 left-2 rounded bg-black/70 px-2 py-1 text-xs text-white\">\n                {currentSize.width} Ã— {currentSize.height}\n              </div>\n            )}\n          </div>\n          {nodeAttrs.caption && (\n            <figcaption className=\"text-muted-foreground mt-2 text-center text-sm\">\n              {nodeAttrs.caption}\n            </figcaption>\n          )}\n        </figure>\n      ) : (\n        <EditorImagePlaceholder\n          onImageReady={handleImageReady}\n          config={extension.options}\n        />\n      )}\n    </NodeViewWrapper>\n  )\n}\n\n// =============================================================================\n// EditorImageExtension\n// =============================================================================\n\nexport interface EditorImageOptions extends EditorImageConfig {\n  inline: boolean\n  HTMLAttributes: Record<string, unknown>\n}\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    editorImage: {\n      setImage: (options: {\n        src?: string | null\n        alt?: string\n        title?: string\n      }) => ReturnType\n    }\n  }\n}\n\nexport const EditorImageExtension = Node.create<EditorImageOptions>({\n  name: \"image\",\n\n  addOptions() {\n    return {\n      inline: false,\n      uploadStrategy: \"base64\",\n      maxFileSize: 5 * 1024 * 1024,\n      acceptedTypes: [\"image/jpeg\", \"image/png\", \"image/gif\", \"image/webp\"],\n      HTMLAttributes: {\n        class: \"rounded-lg border object-contain\",\n      },\n    }\n  },\n\n  inline() {\n    return this.options.inline\n  },\n\n  group() {\n    return this.options.inline ? \"inline\" : \"block\"\n  },\n\n  draggable: true,\n  atom: false,\n\n  addAttributes() {\n    return {\n      src: {\n        default: null,\n        parseHTML: (el) => (el as HTMLImageElement).getAttribute(\"src\"),\n        renderHTML: (attrs) => (attrs.src ? { src: attrs.src } : {}),\n      },\n      alt: {\n        default: null,\n        parseHTML: (el) => (el as HTMLImageElement).getAttribute(\"alt\"),\n        renderHTML: (attrs) => (attrs.alt ? { alt: attrs.alt } : {}),\n      },\n      title: {\n        default: null,\n        parseHTML: (el) => (el as HTMLImageElement).getAttribute(\"title\"),\n        renderHTML: (attrs) => (attrs.title ? { title: attrs.title } : {}),\n      },\n      width: {\n        default: null,\n        parseHTML: (el) => {\n          const width = (el as HTMLImageElement).getAttribute(\"width\")\n          if (!width) return null\n          return width.includes(\"%\") ? width : parseInt(width, 10)\n        },\n        renderHTML: (attrs) => (attrs.width ? { width: attrs.width } : {}),\n      },\n      height: {\n        default: null,\n        parseHTML: (el) => {\n          const height = (el as HTMLImageElement).getAttribute(\"height\")\n          if (!height) return null\n          return height.includes(\"%\") ? height : parseInt(height, 10)\n        },\n        renderHTML: (attrs) => (attrs.height ? { height: attrs.height } : {}),\n      },\n      alignment: {\n        default: \"left\" as EditorImageAlignment,\n        parseHTML: (el) =>\n          (el as HTMLElement).getAttribute(\"data-alignment\") ?? \"left\",\n        renderHTML: (attrs) => ({ \"data-alignment\": attrs.alignment }),\n      },\n      caption: {\n        default: null,\n        parseHTML: (el) => (el as HTMLElement).getAttribute(\"data-caption\"),\n        renderHTML: (attrs) =>\n          attrs.caption ? { \"data-caption\": attrs.caption } : {},\n      },\n      objectFit: {\n        default: \"contain\" as EditorImageObjectFit,\n        parseHTML: (el) =>\n          (el as HTMLElement).getAttribute(\"data-object-fit\") ?? \"contain\",\n        renderHTML: (attrs) => ({ \"data-object-fit\": attrs.objectFit }),\n      },\n      lockAspectRatio: {\n        default: true,\n        parseHTML: (el) =>\n          (el as HTMLElement).getAttribute(\"data-lock-aspect-ratio\") !==\n          \"false\",\n        renderHTML: (attrs) => ({\n          \"data-lock-aspect-ratio\": String(attrs.lockAspectRatio),\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [{ tag: \"img[src]\" }, { tag: \"img\" }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"img\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n    ]\n  },\n\n  addNodeView() {\n    return ReactNodeViewRenderer(ImageNodeView)\n  },\n\n  addCommands() {\n    return {\n      setImage:\n        (options) =>\n        ({ commands }) => {\n          return commands.insertContent({\n            type: this.name,\n            attrs: options,\n          })\n        },\n    }\n  },\n})\n\n// =============================================================================\n// EditorBubbleMenuImage\n// =============================================================================\n\nconst OBJECT_FIT_OPTIONS: { value: EditorImageObjectFit; label: string }[] = [\n  { value: \"contain\", label: \"Contain\" },\n  { value: \"cover\", label: \"Cover\" },\n  { value: \"fill\", label: \"Fill\" },\n  { value: \"none\", label: \"None\" },\n  { value: \"scale-down\", label: \"Scale Down\" },\n]\n\nexport function EditorBubbleMenuImage() {\n  const ctx = React.useContext(EditorContext)\n  const editor = ctx?.editor\n  const [captionOpen, setCaptionOpen] = React.useState(false)\n  const [captionValue, setCaptionValue] = React.useState(\"\")\n  const widthInputRef = React.useRef<HTMLInputElement>(null)\n  const heightInputRef = React.useRef<HTMLInputElement>(null)\n  const [forceUpdate, setForceUpdate] = React.useState(0)\n\n  const isImageActive = editor?.isActive(\"image\") ?? false\n\n  // Subscribe to editor transaction updates to sync dimensions\n  React.useEffect(() => {\n    if (!editor) return\n\n    const handleUpdate = () => {\n      if (editor.isActive(\"image\")) {\n        setForceUpdate((prev) => prev + 1)\n      }\n    }\n\n    editor.on(\"transaction\", handleUpdate)\n    editor.on(\"selectionUpdate\", handleUpdate)\n\n    return () => {\n      editor.off(\"transaction\", handleUpdate)\n      editor.off(\"selectionUpdate\", handleUpdate)\n    }\n  }, [editor])\n\n  const getDefaultDimensions = React.useCallback(() => {\n    if (!editor || !isImageActive) return { width: \"\", height: \"\" }\n\n    const attrs = editor.getAttributes(\"image\")\n\n    if (attrs.width && attrs.height) {\n      return {\n        width: attrs.width.toString(),\n        height: attrs.height.toString(),\n      }\n    }\n\n    const { node } = editor.state.selection as { node?: { type?: { name?: string }, attrs?: { src?: string } } }\n    if (node?.type?.name === \"image\" && node.attrs?.src) {\n      const imageElement = editor.view.dom.querySelector(\n        `img[src=\"${node.attrs.src}\"]`\n      ) as HTMLImageElement | null\n\n      if (imageElement?.complete && imageElement.naturalWidth > 0) {\n        const rect = imageElement.getBoundingClientRect()\n        return {\n          width: Math.round(rect.width).toString(),\n          height: Math.round(rect.height).toString(),\n        }\n      }\n    }\n\n    return { width: \"\", height: \"\" }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor, isImageActive, forceUpdate])\n\n  const defaultDimensions = getDefaultDimensions()\n\n  if (!editor) return null\n\n  const getImageAttrs = () => {\n    if (!isImageActive) return null\n    return editor.getAttributes(\"image\") as {\n      src: string | null\n      alt: string | null\n      width: number | string | null\n      height: number | string | null\n      alignment: EditorImageAlignment\n      caption: string | null\n      objectFit: EditorImageObjectFit\n      lockAspectRatio: boolean\n    }\n  }\n\n  const attrs = getImageAttrs()\n  const isConstrained = attrs?.lockAspectRatio ?? true\n\n  const handleToggleLockAspectRatio = () => {\n    editor\n      .chain()\n      .focus()\n      .updateAttributes(\"image\", { lockAspectRatio: !isConstrained })\n      .run()\n  }\n\n  const parseValue = (\n    value: string\n  ): { numericValue: number; isPercentage: boolean } | null => {\n    const trimmed = value.trim()\n    if (!trimmed) return null\n\n    const isPercentage = trimmed.endsWith(\"%\")\n    const numStr = isPercentage ? trimmed.slice(0, -1) : trimmed\n    const numValue = parseFloat(numStr)\n\n    if (isNaN(numValue) || numValue <= 0) return null\n    if (isPercentage && numValue > 100) return null\n\n    return { numericValue: numValue, isPercentage }\n  }\n\n  const formatValue = (\n    numericValue: number,\n    isPercentage: boolean\n  ): string | number => {\n    return isPercentage ? `${numericValue}%` : Math.round(numericValue)\n  }\n\n  const applyWidth = (value: string) => {\n    const parsed = parseValue(value)\n    if (!parsed) return\n\n    const { numericValue, isPercentage } = parsed\n    const formattedValue = formatValue(numericValue, isPercentage)\n\n    if (\n      isConstrained &&\n      defaultDimensions.width &&\n      defaultDimensions.height &&\n      !isPercentage\n    ) {\n      const currentWidth = parseFloat(defaultDimensions.width)\n      const currentHeight = parseFloat(defaultDimensions.height)\n      if (currentWidth > 0 && currentHeight > 0) {\n        const aspectRatio = currentHeight / currentWidth\n        const newHeight = Math.round(numericValue * aspectRatio)\n        editor\n          .chain()\n          .focus()\n          .updateAttributes(\"image\", {\n            width: formattedValue,\n            height: newHeight,\n          })\n          .run()\n        return\n      }\n    }\n\n    editor\n      .chain()\n      .focus()\n      .updateAttributes(\"image\", { width: formattedValue })\n      .run()\n  }\n\n  const applyHeight = (value: string) => {\n    const parsed = parseValue(value)\n    if (!parsed) return\n\n    const { numericValue, isPercentage } = parsed\n    const formattedValue = formatValue(numericValue, isPercentage)\n\n    if (\n      isConstrained &&\n      defaultDimensions.width &&\n      defaultDimensions.height &&\n      !isPercentage\n    ) {\n      const currentWidth = parseFloat(defaultDimensions.width)\n      const currentHeight = parseFloat(defaultDimensions.height)\n      if (currentWidth > 0 && currentHeight > 0) {\n        const aspectRatio = currentWidth / currentHeight\n        const newWidth = Math.round(numericValue * aspectRatio)\n        editor\n          .chain()\n          .focus()\n          .updateAttributes(\"image\", {\n            width: newWidth,\n            height: formattedValue,\n          })\n          .run()\n        return\n      }\n    }\n\n    editor\n      .chain()\n      .focus()\n      .updateAttributes(\"image\", { height: formattedValue })\n      .run()\n  }\n\n  const handleWidthBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    applyWidth(e.target.value)\n  }\n\n  const handleHeightBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    applyHeight(e.target.value)\n  }\n\n  const handleWidthKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault()\n      applyWidth(e.currentTarget.value)\n    }\n  }\n\n  const handleHeightKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === \"Enter\") {\n      e.preventDefault()\n      applyHeight(e.currentTarget.value)\n    }\n  }\n\n  const handleAlignmentChange = (alignment: EditorImageAlignment) => {\n    editor.chain().focus().updateAttributes(\"image\", { alignment }).run()\n  }\n\n  const handleObjectFitChange = (objectFit: EditorImageObjectFit) => {\n    editor.chain().focus().updateAttributes(\"image\", { objectFit }).run()\n  }\n\n  const handleCaptionSave = () => {\n    editor\n      .chain()\n      .focus()\n      .updateAttributes(\"image\", { caption: captionValue || null })\n      .run()\n    setCaptionOpen(false)\n  }\n\n  const handleCaptionOpen = () => {\n    const attrs = getImageAttrs()\n    setCaptionValue(attrs?.caption ?? \"\")\n    setCaptionOpen(true)\n  }\n\n  const handleDelete = () => {\n    editor.chain().focus().deleteSelection().run()\n  }\n\n  return (\n    <BubbleMenu\n      editor={editor}\n      tippyOptions={{\n        duration: 100,\n        placement: \"bottom\",\n        offset: [0, 8],\n        getReferenceClientRect: () => {\n          const { state, view } = editor\n          const { selection } = state\n\n          const { node } = selection as { node?: { type?: { name?: string }, attrs?: { src?: string } } }\n          if (node?.type?.name === \"image\" && node.attrs?.src) {\n            const imageElement = view.dom.querySelector(\n              `[data-type=\"image\"][data-src=\"${node.attrs.src}\"] img`\n            ) as HTMLImageElement | null\n\n            if (imageElement) {\n              return imageElement.getBoundingClientRect()\n            }\n          }\n\n          const selectedImageWrapper = view.dom.querySelector(\n            '[data-type=\"image\"] .ring-primary'\n          )?.closest('[data-type=\"image\"]') as HTMLElement | null\n\n          if (selectedImageWrapper) {\n            const img = selectedImageWrapper.querySelector(\"img\")\n            if (img) {\n              return img.getBoundingClientRect()\n            }\n          }\n\n          const { from, to } = selection\n          const start = view.coordsAtPos(from)\n          const end = view.coordsAtPos(to)\n\n          return new DOMRect(\n            start.left,\n            start.top,\n            end.right - start.left,\n            end.bottom - start.top\n          )\n        },\n      }}\n      shouldShow={({ editor: e }) => e.isActive(\"image\")}\n      className=\"w-fit\"\n    >\n      <div className=\"bg-popover flex items-center gap-1 rounded-md border p-1 shadow-md\">\n        {/* Size Controls */}\n        <div className=\"flex items-center gap-1\">\n          <Input\n            ref={widthInputRef}\n            key={`width-${defaultDimensions.width}-${isConstrained}`}\n            type=\"text\"\n            placeholder=\"W\"\n            defaultValue={defaultDimensions.width}\n            onBlur={handleWidthBlur}\n            onKeyDown={handleWidthKeyDown}\n            className=\"h-7 w-16 text-xs\"\n          />\n          <Button\n            variant={isConstrained ? \"secondary\" : \"ghost\"}\n            size=\"sm\"\n            className=\"h-7 w-7 p-0\"\n            onClick={handleToggleLockAspectRatio}\n            title={isConstrained ? \"Unlock aspect ratio\" : \"Lock aspect ratio\"}\n          >\n            {isConstrained ? (\n              <Lock className=\"size-2\" />\n            ) : (\n              <LockOpen className=\"size-2\" />\n            )}\n          </Button>\n          <Input\n            ref={heightInputRef}\n            key={`height-${defaultDimensions.height}-${isConstrained}`}\n            type=\"text\"\n            placeholder=\"H\"\n            defaultValue={defaultDimensions.height}\n            onBlur={handleHeightBlur}\n            onKeyDown={handleHeightKeyDown}\n            className=\"h-7 w-16 text-xs\"\n          />\n        </div>\n\n        <div className=\"bg-border mx-1 h-5 w-px\" />\n\n        {/* Alignment Controls */}\n        <div className=\"flex items-center gap-0.5\">\n          <Button\n            variant={attrs?.alignment === \"left\" ? \"secondary\" : \"ghost\"}\n            size=\"sm\"\n            className=\"h-7 w-7 p-0\"\n            onClick={() => handleAlignmentChange(\"left\")}\n            title=\"Align left\"\n          >\n            <AlignLeft className=\"size-3.5\" />\n          </Button>\n          <Button\n            variant={attrs?.alignment === \"center\" ? \"secondary\" : \"ghost\"}\n            size=\"sm\"\n            className=\"h-7 w-7 p-0\"\n            onClick={() => handleAlignmentChange(\"center\")}\n            title=\"Align center\"\n          >\n            <AlignCenter className=\"size-3.5\" />\n          </Button>\n          <Button\n            variant={attrs?.alignment === \"right\" ? \"secondary\" : \"ghost\"}\n            size=\"sm\"\n            className=\"h-7 w-7 p-0\"\n            onClick={() => handleAlignmentChange(\"right\")}\n            title=\"Align right\"\n          >\n            <AlignRight className=\"size-3.5\" />\n          </Button>\n        </div>\n\n        <div className=\"bg-border mx-1 h-5 w-px\" />\n\n        {/* Object Fit Selector */}\n        <DropdownMenu>\n          <DropdownMenuTrigger asChild>\n            <Button variant=\"ghost\" size=\"sm\" className=\"h-7 gap-1 px-2 text-xs\">\n              {OBJECT_FIT_OPTIONS.find((o) => o.value === attrs?.objectFit)\n                ?.label || \"Contain\"}\n              <ChevronDown className=\"size-3 opacity-50\" />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContentPrimitive\n            className={cn(\n              \"bg-popover text-popover-foreground z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md\",\n              \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95\"\n            )}\n            align=\"start\"\n            sideOffset={8}\n          >\n            {OBJECT_FIT_OPTIONS.map((option) => (\n              <DropdownMenuItem\n                key={option.value}\n                onClick={() => handleObjectFitChange(option.value)}\n              >\n                {option.label}\n                {attrs?.objectFit === option.value && (\n                  <Check className=\"ml-auto size-4\" />\n                )}\n              </DropdownMenuItem>\n            ))}\n          </DropdownMenuContentPrimitive>\n        </DropdownMenu>\n\n        <div className=\"bg-border mx-1 h-5 w-px\" />\n\n        {/* Caption Popover */}\n        <Popover open={captionOpen} onOpenChange={setCaptionOpen}>\n          <PopoverTrigger asChild>\n            <Button\n              variant={attrs?.caption ? \"secondary\" : \"ghost\"}\n              size=\"sm\"\n              className=\"h-7 gap-1 px-2 text-xs\"\n              onClick={handleCaptionOpen}\n              title=\"Add caption\"\n            >\n              <MessageSquare className=\"size-3.5\" />\n              Caption\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-64 p-3\" align=\"start\" sideOffset={8}>\n            <div className=\"space-y-2\">\n              <p className=\"text-sm font-medium\">Image Caption</p>\n              <Input\n                placeholder=\"Enter caption...\"\n                value={captionValue}\n                onChange={(e) => setCaptionValue(e.target.value)}\n                onKeyDown={(e) => {\n                  if (e.key === \"Enter\") {\n                    e.preventDefault()\n                    handleCaptionSave()\n                  }\n                }}\n              />\n              <div className=\"flex justify-end gap-2\">\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setCaptionValue(\"\")\n                    editor\n                      .chain()\n                      .focus()\n                      .updateAttributes(\"image\", { caption: null })\n                      .run()\n                    setCaptionOpen(false)\n                  }}\n                >\n                  Clear\n                </Button>\n                <Button size=\"sm\" onClick={handleCaptionSave}>\n                  Save\n                </Button>\n              </div>\n            </div>\n          </PopoverContent>\n        </Popover>\n\n        <div className=\"bg-border mx-1 h-5 w-px\" />\n\n        {/* Delete Button */}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          className=\"text-destructive hover:text-destructive hover:bg-destructive/10 h-7 w-7 p-0\"\n          onClick={handleDelete}\n          title=\"Delete image\"\n        >\n          <Trash2 className=\"size-3.5\" />\n        </Button>\n      </div>\n    </BubbleMenu>\n  )\n}\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:ui"
}